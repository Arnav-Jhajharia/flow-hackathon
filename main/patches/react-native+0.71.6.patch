diff --git a/node_modules/react-native/ReactAndroid/src/main/jni/react/turbomodule/.DS_Store b/node_modules/react-native/ReactAndroid/src/main/jni/react/turbomodule/.DS_Store
new file mode 100644
index 0000000..59ad10c
Binary files /dev/null and b/node_modules/react-native/ReactAndroid/src/main/jni/react/turbomodule/.DS_Store differ
diff --git a/node_modules/react-native/ReactCommon/yoga/yoga/Yoga.cpp b/node_modules/react-native/ReactCommon/yoga/yoga/Yoga.cpp
index a66adec..f250ee2 100644
--- a/node_modules/react-native/ReactCommon/yoga/yoga/Yoga.cpp
+++ b/node_modules/react-native/ReactCommon/yoga/yoga/Yoga.cpp
@@ -22,7 +22,8 @@
 
 /* define fmaxf if < VC12 */
 #if _MSC_VER < 1800
-__forceinline const float fmaxf(const float a, const float b) {
+__forceinline const float fmaxf(const float a, const float b)
+{
   return (a > b) ? a : b;
 }
 #endif
@@ -36,14 +37,14 @@ static int YGAndroidLog(
     const YGConfigRef config,
     const YGNodeRef node,
     YGLogLevel level,
-    const char* format,
+    const char *format,
     va_list args);
 #else
 static int YGDefaultLog(
     const YGConfigRef config,
     const YGNodeRef node,
     YGLogLevel level,
-    const char* format,
+    const char *format,
     va_list args);
 #endif
 
@@ -53,145 +54,169 @@ static int YGAndroidLog(
     const YGConfigRef config,
     const YGNodeRef node,
     YGLogLevel level,
-    const char* format,
-    va_list args) {
+    const char *format,
+    va_list args)
+{
   int androidLevel = YGLogLevelDebug;
-  switch (level) {
-    case YGLogLevelFatal:
-      androidLevel = ANDROID_LOG_FATAL;
-      break;
-    case YGLogLevelError:
-      androidLevel = ANDROID_LOG_ERROR;
-      break;
-    case YGLogLevelWarn:
-      androidLevel = ANDROID_LOG_WARN;
-      break;
-    case YGLogLevelInfo:
-      androidLevel = ANDROID_LOG_INFO;
-      break;
-    case YGLogLevelDebug:
-      androidLevel = ANDROID_LOG_DEBUG;
-      break;
-    case YGLogLevelVerbose:
-      androidLevel = ANDROID_LOG_VERBOSE;
-      break;
+  switch (level)
+  {
+  case YGLogLevelFatal:
+    androidLevel = ANDROID_LOG_FATAL;
+    break;
+  case YGLogLevelError:
+    androidLevel = ANDROID_LOG_ERROR;
+    break;
+  case YGLogLevelWarn:
+    androidLevel = ANDROID_LOG_WARN;
+    break;
+  case YGLogLevelInfo:
+    androidLevel = ANDROID_LOG_INFO;
+    break;
+  case YGLogLevelDebug:
+    androidLevel = ANDROID_LOG_DEBUG;
+    break;
+  case YGLogLevelVerbose:
+    androidLevel = ANDROID_LOG_VERBOSE;
+    break;
   }
   const int result = __android_log_vprint(androidLevel, "yoga", format, args);
   return result;
 }
 #else
-#define YG_UNUSED(x) (void) (x);
+#define YG_UNUSED(x) (void)(x);
 
 static int YGDefaultLog(
     const YGConfigRef config,
     const YGNodeRef node,
     YGLogLevel level,
-    const char* format,
-    va_list args) {
+    const char *format,
+    va_list args)
+{
   YG_UNUSED(config);
   YG_UNUSED(node);
-  switch (level) {
-    case YGLogLevelError:
-    case YGLogLevelFatal:
-      return vfprintf(stderr, format, args);
-    case YGLogLevelWarn:
-    case YGLogLevelInfo:
-    case YGLogLevelDebug:
-    case YGLogLevelVerbose:
-    default:
-      return vprintf(format, args);
+  switch (level)
+  {
+  case YGLogLevelError:
+  case YGLogLevelFatal:
+    return vfprintf(stderr, format, args);
+  case YGLogLevelWarn:
+  case YGLogLevelInfo:
+  case YGLogLevelDebug:
+  case YGLogLevelVerbose:
+  default:
+    return vprintf(format, args);
   }
 }
 
 #undef YG_UNUSED
 #endif
 
-static inline bool YGDoubleIsUndefined(const double value) {
+static inline bool YGDoubleIsUndefined(const double value)
+{
   return facebook::yoga::isUndefined(value);
 }
 
-YOGA_EXPORT bool YGFloatIsUndefined(const float value) {
+YOGA_EXPORT bool YGFloatIsUndefined(const float value)
+{
   return facebook::yoga::isUndefined(value);
 }
 
-YOGA_EXPORT void* YGNodeGetContext(YGNodeRef node) {
+YOGA_EXPORT void *YGNodeGetContext(YGNodeRef node)
+{
   return node->getContext();
 }
 
-YOGA_EXPORT void YGNodeSetContext(YGNodeRef node, void* context) {
+YOGA_EXPORT void YGNodeSetContext(YGNodeRef node, void *context)
+{
   return node->setContext(context);
 }
 
-YOGA_EXPORT bool YGNodeHasMeasureFunc(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeHasMeasureFunc(YGNodeRef node)
+{
   return node->hasMeasureFunc();
 }
 
 YOGA_EXPORT void YGNodeSetMeasureFunc(
     YGNodeRef node,
-    YGMeasureFunc measureFunc) {
+    YGMeasureFunc measureFunc)
+{
   node->setMeasureFunc(measureFunc);
 }
 
-YOGA_EXPORT bool YGNodeHasBaselineFunc(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeHasBaselineFunc(YGNodeRef node)
+{
   return node->hasBaselineFunc();
 }
 
 YOGA_EXPORT void YGNodeSetBaselineFunc(
     YGNodeRef node,
-    YGBaselineFunc baselineFunc) {
+    YGBaselineFunc baselineFunc)
+{
   node->setBaselineFunc(baselineFunc);
 }
 
-YOGA_EXPORT YGDirtiedFunc YGNodeGetDirtiedFunc(YGNodeRef node) {
+YOGA_EXPORT YGDirtiedFunc YGNodeGetDirtiedFunc(YGNodeRef node)
+{
   return node->getDirtied();
 }
 
 YOGA_EXPORT void YGNodeSetDirtiedFunc(
     YGNodeRef node,
-    YGDirtiedFunc dirtiedFunc) {
+    YGDirtiedFunc dirtiedFunc)
+{
   node->setDirtiedFunc(dirtiedFunc);
 }
 
-YOGA_EXPORT void YGNodeSetPrintFunc(YGNodeRef node, YGPrintFunc printFunc) {
+YOGA_EXPORT void YGNodeSetPrintFunc(YGNodeRef node, YGPrintFunc printFunc)
+{
   node->setPrintFunc(printFunc);
 }
 
-YOGA_EXPORT bool YGNodeGetHasNewLayout(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeGetHasNewLayout(YGNodeRef node)
+{
   return node->getHasNewLayout();
 }
 
-YOGA_EXPORT void YGConfigSetPrintTreeFlag(YGConfigRef config, bool enabled) {
+YOGA_EXPORT void YGConfigSetPrintTreeFlag(YGConfigRef config, bool enabled)
+{
   config->printTree = enabled;
 }
 
-YOGA_EXPORT void YGNodeSetHasNewLayout(YGNodeRef node, bool hasNewLayout) {
+YOGA_EXPORT void YGNodeSetHasNewLayout(YGNodeRef node, bool hasNewLayout)
+{
   node->setHasNewLayout(hasNewLayout);
 }
 
-YOGA_EXPORT YGNodeType YGNodeGetNodeType(YGNodeRef node) {
+YOGA_EXPORT YGNodeType YGNodeGetNodeType(YGNodeRef node)
+{
   return node->getNodeType();
 }
 
-YOGA_EXPORT void YGNodeSetNodeType(YGNodeRef node, YGNodeType nodeType) {
+YOGA_EXPORT void YGNodeSetNodeType(YGNodeRef node, YGNodeType nodeType)
+{
   return node->setNodeType(nodeType);
 }
 
-YOGA_EXPORT bool YGNodeIsDirty(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeIsDirty(YGNodeRef node)
+{
   return node->isDirty();
 }
 
-YOGA_EXPORT bool YGNodeLayoutGetDidUseLegacyFlag(const YGNodeRef node) {
+YOGA_EXPORT bool YGNodeLayoutGetDidUseLegacyFlag(const YGNodeRef node)
+{
   return node->didUseLegacyFlag();
 }
 
 YOGA_EXPORT void YGNodeMarkDirtyAndPropogateToDescendants(
-    const YGNodeRef node) {
+    const YGNodeRef node)
+{
   return node->markDirtyAndPropogateDownwards();
 }
 
 int32_t gConfigInstanceCount = 0;
 
-YOGA_EXPORT WIN_EXPORT YGNodeRef YGNodeNewWithConfig(const YGConfigRef config) {
+YOGA_EXPORT WIN_EXPORT YGNodeRef YGNodeNewWithConfig(const YGConfigRef config)
+{
   const YGNodeRef node = new YGNode{config};
   YGAssertWithConfig(
       config, node != nullptr, "Could not allocate memory for node");
@@ -200,16 +225,19 @@ YOGA_EXPORT WIN_EXPORT YGNodeRef YGNodeNewWithConfig(const YGConfigRef config) {
   return node;
 }
 
-YOGA_EXPORT YGConfigRef YGConfigGetDefault() {
+YOGA_EXPORT YGConfigRef YGConfigGetDefault()
+{
   static YGConfigRef defaultConfig = YGConfigNew();
   return defaultConfig;
 }
 
-YOGA_EXPORT YGNodeRef YGNodeNew(void) {
+YOGA_EXPORT YGNodeRef YGNodeNew(void)
+{
   return YGNodeNewWithConfig(YGConfigGetDefault());
 }
 
-YOGA_EXPORT YGNodeRef YGNodeClone(YGNodeRef oldNode) {
+YOGA_EXPORT YGNodeRef YGNodeClone(YGNodeRef oldNode)
+{
   YGNodeRef node = new YGNode(*oldNode);
   YGAssertWithConfig(
       oldNode->getConfig(),
@@ -220,14 +248,16 @@ YOGA_EXPORT YGNodeRef YGNodeClone(YGNodeRef oldNode) {
   return node;
 }
 
-static YGConfigRef YGConfigClone(const YGConfig& oldConfig) {
+static YGConfigRef YGConfigClone(const YGConfig &oldConfig)
+{
   const YGConfigRef config = new YGConfig(oldConfig);
   YGAssert(config != nullptr, "Could not allocate memory for config");
   gConfigInstanceCount++;
   return config;
 }
 
-static YGNodeRef YGNodeDeepClone(YGNodeRef oldNode) {
+static YGNodeRef YGNodeDeepClone(YGNodeRef oldNode)
+{
   auto config = YGConfigClone(*oldNode->getConfig());
   auto node = new YGNode{*oldNode, config};
   node->setOwner(nullptr);
@@ -236,7 +266,8 @@ static YGNodeRef YGNodeDeepClone(YGNodeRef oldNode) {
   YGVector vec = YGVector();
   vec.reserve(oldNode->getChildren().size());
   YGNodeRef childNode = nullptr;
-  for (auto* item : oldNode->getChildren()) {
+  for (auto *item : oldNode->getChildren())
+  {
     childNode = YGNodeDeepClone(item);
     childNode->setOwner(node);
     vec.push_back(childNode);
@@ -246,14 +277,17 @@ static YGNodeRef YGNodeDeepClone(YGNodeRef oldNode) {
   return node;
 }
 
-YOGA_EXPORT void YGNodeFree(const YGNodeRef node) {
-  if (YGNodeRef owner = node->getOwner()) {
+YOGA_EXPORT void YGNodeFree(const YGNodeRef node)
+{
+  if (YGNodeRef owner = node->getOwner())
+  {
     owner->removeChild(node);
     node->setOwner(nullptr);
   }
 
   const uint32_t childCount = YGNodeGetChildCount(node);
-  for (uint32_t i = 0; i < childCount; i++) {
+  for (uint32_t i = 0; i < childCount; i++)
+  {
     const YGNodeRef child = YGNodeGetChild(node, i);
     child->setOwner(nullptr);
   }
@@ -263,50 +297,63 @@ YOGA_EXPORT void YGNodeFree(const YGNodeRef node) {
   delete node;
 }
 
-static void YGConfigFreeRecursive(const YGNodeRef root) {
-  if (root->getConfig() != nullptr) {
+static void YGConfigFreeRecursive(const YGNodeRef root)
+{
+  if (root->getConfig() != nullptr)
+  {
     gConfigInstanceCount--;
     delete root->getConfig();
   }
   // Delete configs recursively for childrens
-  for (auto* child : root->getChildren()) {
+  for (auto *child : root->getChildren())
+  {
     YGConfigFreeRecursive(child);
   }
 }
 
 YOGA_EXPORT void YGNodeFreeRecursiveWithCleanupFunc(
     const YGNodeRef root,
-    YGNodeCleanupFunc cleanup) {
+    YGNodeCleanupFunc cleanup)
+{
   uint32_t skipped = 0;
-  while (YGNodeGetChildCount(root) > skipped) {
+  while (YGNodeGetChildCount(root) > skipped)
+  {
     const YGNodeRef child = YGNodeGetChild(root, skipped);
-    if (child->getOwner() != root) {
+    if (child->getOwner() != root)
+    {
       // Don't free shared nodes that we don't own.
       skipped += 1;
-    } else {
+    }
+    else
+    {
       YGNodeRemoveChild(root, child);
       YGNodeFreeRecursive(child);
     }
   }
-  if (cleanup != nullptr) {
+  if (cleanup != nullptr)
+  {
     cleanup(root);
   }
   YGNodeFree(root);
 }
 
-YOGA_EXPORT void YGNodeFreeRecursive(const YGNodeRef root) {
+YOGA_EXPORT void YGNodeFreeRecursive(const YGNodeRef root)
+{
   return YGNodeFreeRecursiveWithCleanupFunc(root, nullptr);
 }
 
-YOGA_EXPORT void YGNodeReset(YGNodeRef node) {
+YOGA_EXPORT void YGNodeReset(YGNodeRef node)
+{
   node->reset();
 }
 
-YOGA_EXPORT int32_t YGConfigGetInstanceCount(void) {
+YOGA_EXPORT int32_t YGConfigGetInstanceCount(void)
+{
   return gConfigInstanceCount;
 }
 
-YOGA_EXPORT YGConfigRef YGConfigNew(void) {
+YOGA_EXPORT YGConfigRef YGConfigNew(void)
+{
 #ifdef ANDROID
   const YGConfigRef config = new YGConfig(YGAndroidLog);
 #else
@@ -316,32 +363,38 @@ YOGA_EXPORT YGConfigRef YGConfigNew(void) {
   return config;
 }
 
-YOGA_EXPORT void YGConfigFree(const YGConfigRef config) {
+YOGA_EXPORT void YGConfigFree(const YGConfigRef config)
+{
   delete config;
   gConfigInstanceCount--;
 }
 
-void YGConfigCopy(const YGConfigRef dest, const YGConfigRef src) {
+void YGConfigCopy(const YGConfigRef dest, const YGConfigRef src)
+{
   memcpy(dest, src, sizeof(YGConfig));
 }
 
 YOGA_EXPORT void YGNodeSetIsReferenceBaseline(
     YGNodeRef node,
-    bool isReferenceBaseline) {
-  if (node->isReferenceBaseline() != isReferenceBaseline) {
+    bool isReferenceBaseline)
+{
+  if (node->isReferenceBaseline() != isReferenceBaseline)
+  {
     node->setIsReferenceBaseline(isReferenceBaseline);
     node->markDirtyAndPropogate();
   }
 }
 
-YOGA_EXPORT bool YGNodeIsReferenceBaseline(YGNodeRef node) {
+YOGA_EXPORT bool YGNodeIsReferenceBaseline(YGNodeRef node)
+{
   return node->isReferenceBaseline();
 }
 
 YOGA_EXPORT void YGNodeInsertChild(
     const YGNodeRef owner,
     const YGNodeRef child,
-    const uint32_t index) {
+    const uint32_t index)
+{
   YGAssertWithNode(
       owner,
       child->getOwner() == nullptr,
@@ -360,15 +413,18 @@ YOGA_EXPORT void YGNodeInsertChild(
 YOGA_EXPORT void YGNodeSwapChild(
     const YGNodeRef owner,
     const YGNodeRef child,
-    const uint32_t index) {
+    const uint32_t index)
+{
   owner->replaceChild(child, index);
   child->setOwner(owner);
 }
 
 YOGA_EXPORT void YGNodeRemoveChild(
     const YGNodeRef owner,
-    const YGNodeRef excludedChild) {
-  if (YGNodeGetChildCount(owner) == 0) {
+    const YGNodeRef excludedChild)
+{
+  if (YGNodeGetChildCount(owner) == 0)
+  {
     // This is an empty set. Nothing to remove.
     return;
   }
@@ -377,8 +433,10 @@ YOGA_EXPORT void YGNodeRemoveChild(
   // owner. We only want to reset the child completely if it is owned
   // exclusively by one node.
   auto childOwner = excludedChild->getOwner();
-  if (owner->removeChild(excludedChild)) {
-    if (owner == childOwner) {
+  if (owner->removeChild(excludedChild))
+  {
+    if (owner == childOwner)
+    {
       excludedChild->setLayout({}); // layout is no longer valid
       excludedChild->setOwner(nullptr);
     }
@@ -386,17 +444,21 @@ YOGA_EXPORT void YGNodeRemoveChild(
   }
 }
 
-YOGA_EXPORT void YGNodeRemoveAllChildren(const YGNodeRef owner) {
+YOGA_EXPORT void YGNodeRemoveAllChildren(const YGNodeRef owner)
+{
   const uint32_t childCount = YGNodeGetChildCount(owner);
-  if (childCount == 0) {
+  if (childCount == 0)
+  {
     // This is an empty set already. Nothing to do.
     return;
   }
   const YGNodeRef firstChild = YGNodeGetChild(owner, 0);
-  if (firstChild->getOwner() == owner) {
+  if (firstChild->getOwner() == owner)
+  {
     // If the first child has this node as its owner, we assume that this child
     // set is unique.
-    for (uint32_t i = 0; i < childCount; i++) {
+    for (uint32_t i = 0; i < childCount; i++)
+    {
       const YGNodeRef oldChild = YGNodeGetChild(owner, i);
       oldChild->setLayout(YGNode().getLayout()); // layout is no longer valid
       oldChild->setOwner(nullptr);
@@ -413,33 +475,44 @@ YOGA_EXPORT void YGNodeRemoveAllChildren(const YGNodeRef owner) {
 
 static void YGNodeSetChildrenInternal(
     YGNodeRef const owner,
-    const std::vector<YGNodeRef>& children) {
-  if (!owner) {
+    const std::vector<YGNodeRef> &children)
+{
+  if (!owner)
+  {
     return;
   }
-  if (children.size() == 0) {
-    if (YGNodeGetChildCount(owner) > 0) {
-      for (YGNodeRef const child : owner->getChildren()) {
+  if (children.size() == 0)
+  {
+    if (YGNodeGetChildCount(owner) > 0)
+    {
+      for (YGNodeRef const child : owner->getChildren())
+      {
         child->setLayout(YGLayout());
         child->setOwner(nullptr);
       }
       owner->setChildren(YGVector());
       owner->markDirtyAndPropogate();
     }
-  } else {
-    if (YGNodeGetChildCount(owner) > 0) {
-      for (YGNodeRef const oldChild : owner->getChildren()) {
+  }
+  else
+  {
+    if (YGNodeGetChildCount(owner) > 0)
+    {
+      for (YGNodeRef const oldChild : owner->getChildren())
+      {
         // Our new children may have nodes in common with the old children. We
         // don't reset these common nodes.
         if (std::find(children.begin(), children.end(), oldChild) ==
-            children.end()) {
+            children.end())
+        {
           oldChild->setLayout(YGLayout());
           oldChild->setOwner(nullptr);
         }
       }
     }
     owner->setChildren(children);
-    for (YGNodeRef child : children) {
+    for (YGNodeRef child : children)
+    {
       child->setOwner(owner);
     }
     owner->markDirtyAndPropogate();
@@ -449,38 +522,46 @@ static void YGNodeSetChildrenInternal(
 YOGA_EXPORT void YGNodeSetChildren(
     const YGNodeRef owner,
     const YGNodeRef c[],
-    const uint32_t count) {
+    const uint32_t count)
+{
   const YGVector children = {c, c + count};
   YGNodeSetChildrenInternal(owner, children);
 }
 
 YOGA_EXPORT void YGNodeSetChildren(
     YGNodeRef const owner,
-    const std::vector<YGNodeRef>& children) {
+    const std::vector<YGNodeRef> &children)
+{
   YGNodeSetChildrenInternal(owner, children);
 }
 
 YOGA_EXPORT YGNodeRef
-YGNodeGetChild(const YGNodeRef node, const uint32_t index) {
-  if (index < node->getChildren().size()) {
+YGNodeGetChild(const YGNodeRef node, const uint32_t index)
+{
+  if (index < node->getChildren().size())
+  {
     return node->getChild(index);
   }
   return nullptr;
 }
 
-YOGA_EXPORT uint32_t YGNodeGetChildCount(const YGNodeRef node) {
+YOGA_EXPORT uint32_t YGNodeGetChildCount(const YGNodeRef node)
+{
   return static_cast<uint32_t>(node->getChildren().size());
 }
 
-YOGA_EXPORT YGNodeRef YGNodeGetOwner(const YGNodeRef node) {
+YOGA_EXPORT YGNodeRef YGNodeGetOwner(const YGNodeRef node)
+{
   return node->getOwner();
 }
 
-YOGA_EXPORT YGNodeRef YGNodeGetParent(const YGNodeRef node) {
+YOGA_EXPORT YGNodeRef YGNodeGetParent(const YGNodeRef node)
+{
   return node->getOwner();
 }
 
-YOGA_EXPORT void YGNodeMarkDirty(const YGNodeRef node) {
+YOGA_EXPORT void YGNodeMarkDirty(const YGNodeRef node)
+{
   YGAssertWithNode(
       node,
       node->hasMeasureFunc(),
@@ -492,62 +573,75 @@ YOGA_EXPORT void YGNodeMarkDirty(const YGNodeRef node) {
 
 YOGA_EXPORT void YGNodeCopyStyle(
     const YGNodeRef dstNode,
-    const YGNodeRef srcNode) {
-  if (!(dstNode->getStyle() == srcNode->getStyle())) {
+    const YGNodeRef srcNode)
+{
+  if (!(dstNode->getStyle() == srcNode->getStyle()))
+  {
     dstNode->setStyle(srcNode->getStyle());
     dstNode->markDirtyAndPropogate();
   }
 }
 
-YOGA_EXPORT float YGNodeStyleGetFlexGrow(const YGNodeConstRef node) {
+YOGA_EXPORT float YGNodeStyleGetFlexGrow(const YGNodeConstRef node)
+{
   return node->getStyle().flexGrow().isUndefined()
-      ? kDefaultFlexGrow
-      : node->getStyle().flexGrow().unwrap();
+             ? kDefaultFlexGrow
+             : node->getStyle().flexGrow().unwrap();
 }
 
-YOGA_EXPORT float YGNodeStyleGetFlexShrink(const YGNodeConstRef node) {
+YOGA_EXPORT float YGNodeStyleGetFlexShrink(const YGNodeConstRef node)
+{
   return node->getStyle().flexShrink().isUndefined()
-      ? (node->getConfig()->useWebDefaults ? kWebDefaultFlexShrink
-                                           : kDefaultFlexShrink)
-      : node->getStyle().flexShrink().unwrap();
-}
-
-namespace {
+             ? (node->getConfig()->useWebDefaults ? kWebDefaultFlexShrink
+                                                  : kDefaultFlexShrink)
+             : node->getStyle().flexShrink().unwrap();
+}
+
+namespace
+{
+
+  template <typename T, typename NeedsUpdate, typename Update>
+  void updateStyle(
+      YGNode *node,
+      T value,
+      NeedsUpdate &&needsUpdate,
+      Update &&update)
+  {
+    if (needsUpdate(node->getStyle(), value))
+    {
+      update(node->getStyle(), value);
+      node->markDirtyAndPropogate();
+    }
+  }
 
-template <typename T, typename NeedsUpdate, typename Update>
-void updateStyle(
-    YGNode* node,
-    T value,
-    NeedsUpdate&& needsUpdate,
-    Update&& update) {
-  if (needsUpdate(node->getStyle(), value)) {
-    update(node->getStyle(), value);
-    node->markDirtyAndPropogate();
+  template <typename Ref, typename T>
+  void updateStyle(YGNode *node, Ref (YGStyle::*prop)(), T value)
+  {
+    updateStyle(
+        node,
+        value,
+        [prop](YGStyle &s, T x)
+        { return (s.*prop)() != x; },
+        [prop](YGStyle &s, T x)
+        { (s.*prop)() = x; });
   }
-}
 
-template <typename Ref, typename T>
-void updateStyle(YGNode* node, Ref (YGStyle::*prop)(), T value) {
-  updateStyle(
-      node,
-      value,
-      [prop](YGStyle& s, T x) { return (s.*prop)() != x; },
-      [prop](YGStyle& s, T x) { (s.*prop)() = x; });
-}
-
-template <typename Ref, typename Idx>
-void updateIndexedStyleProp(
-    YGNode* node,
-    Ref (YGStyle::*prop)(),
-    Idx idx,
-    detail::CompactValue value) {
-  using detail::CompactValue;
-  updateStyle(
-      node,
-      value,
-      [idx, prop](YGStyle& s, CompactValue x) { return (s.*prop)()[idx] != x; },
-      [idx, prop](YGStyle& s, CompactValue x) { (s.*prop)()[idx] = x; });
-}
+  template <typename Ref, typename Idx>
+  void updateIndexedStyleProp(
+      YGNode *node,
+      Ref (YGStyle::*prop)(),
+      Idx idx,
+      detail::CompactValue value)
+  {
+    using detail::CompactValue;
+    updateStyle(
+        node,
+        value,
+        [idx, prop](YGStyle &s, CompactValue x)
+        { return (s.*prop)()[idx] != x; },
+        [idx, prop](YGStyle &s, CompactValue x)
+        { (s.*prop)()[idx] = x; });
+  }
 
 } // namespace
 
@@ -560,116 +654,139 @@ void updateIndexedStyleProp(
 
 YOGA_EXPORT void YGNodeStyleSetDirection(
     const YGNodeRef node,
-    const YGDirection value) {
+    const YGDirection value)
+{
   updateStyle<MSVC_HINT(direction)>(node, &YGStyle::direction, value);
 }
-YOGA_EXPORT YGDirection YGNodeStyleGetDirection(const YGNodeConstRef node) {
+YOGA_EXPORT YGDirection YGNodeStyleGetDirection(const YGNodeConstRef node)
+{
   return node->getStyle().direction();
 }
 
 YOGA_EXPORT void YGNodeStyleSetFlexDirection(
     const YGNodeRef node,
-    const YGFlexDirection flexDirection) {
+    const YGFlexDirection flexDirection)
+{
   updateStyle<MSVC_HINT(flexDirection)>(
       node, &YGStyle::flexDirection, flexDirection);
 }
 YOGA_EXPORT YGFlexDirection
-YGNodeStyleGetFlexDirection(const YGNodeConstRef node) {
+YGNodeStyleGetFlexDirection(const YGNodeConstRef node)
+{
   return node->getStyle().flexDirection();
 }
 
 YOGA_EXPORT void YGNodeStyleSetJustifyContent(
     const YGNodeRef node,
-    const YGJustify justifyContent) {
+    const YGJustify justifyContent)
+{
   updateStyle<MSVC_HINT(justifyContent)>(
       node, &YGStyle::justifyContent, justifyContent);
 }
-YOGA_EXPORT YGJustify YGNodeStyleGetJustifyContent(const YGNodeConstRef node) {
+YOGA_EXPORT YGJustify YGNodeStyleGetJustifyContent(const YGNodeConstRef node)
+{
   return node->getStyle().justifyContent();
 }
 
 YOGA_EXPORT void YGNodeStyleSetAlignContent(
     const YGNodeRef node,
-    const YGAlign alignContent) {
+    const YGAlign alignContent)
+{
   updateStyle<MSVC_HINT(alignContent)>(
       node, &YGStyle::alignContent, alignContent);
 }
-YOGA_EXPORT YGAlign YGNodeStyleGetAlignContent(const YGNodeConstRef node) {
+YOGA_EXPORT YGAlign YGNodeStyleGetAlignContent(const YGNodeConstRef node)
+{
   return node->getStyle().alignContent();
 }
 
 YOGA_EXPORT void YGNodeStyleSetAlignItems(
     const YGNodeRef node,
-    const YGAlign alignItems) {
+    const YGAlign alignItems)
+{
   updateStyle<MSVC_HINT(alignItems)>(node, &YGStyle::alignItems, alignItems);
 }
-YOGA_EXPORT YGAlign YGNodeStyleGetAlignItems(const YGNodeConstRef node) {
+YOGA_EXPORT YGAlign YGNodeStyleGetAlignItems(const YGNodeConstRef node)
+{
   return node->getStyle().alignItems();
 }
 
 YOGA_EXPORT void YGNodeStyleSetAlignSelf(
     const YGNodeRef node,
-    const YGAlign alignSelf) {
+    const YGAlign alignSelf)
+{
   updateStyle<MSVC_HINT(alignSelf)>(node, &YGStyle::alignSelf, alignSelf);
 }
-YOGA_EXPORT YGAlign YGNodeStyleGetAlignSelf(const YGNodeConstRef node) {
+YOGA_EXPORT YGAlign YGNodeStyleGetAlignSelf(const YGNodeConstRef node)
+{
   return node->getStyle().alignSelf();
 }
 
 YOGA_EXPORT void YGNodeStyleSetPositionType(
     const YGNodeRef node,
-    const YGPositionType positionType) {
+    const YGPositionType positionType)
+{
   updateStyle<MSVC_HINT(positionType)>(
       node, &YGStyle::positionType, positionType);
 }
 YOGA_EXPORT YGPositionType
-YGNodeStyleGetPositionType(const YGNodeConstRef node) {
+YGNodeStyleGetPositionType(const YGNodeConstRef node)
+{
   return node->getStyle().positionType();
 }
 
 YOGA_EXPORT void YGNodeStyleSetFlexWrap(
     const YGNodeRef node,
-    const YGWrap flexWrap) {
+    const YGWrap flexWrap)
+{
   updateStyle<MSVC_HINT(flexWrap)>(node, &YGStyle::flexWrap, flexWrap);
 }
-YOGA_EXPORT YGWrap YGNodeStyleGetFlexWrap(const YGNodeConstRef node) {
+YOGA_EXPORT YGWrap YGNodeStyleGetFlexWrap(const YGNodeConstRef node)
+{
   return node->getStyle().flexWrap();
 }
 
 YOGA_EXPORT void YGNodeStyleSetOverflow(
     const YGNodeRef node,
-    const YGOverflow overflow) {
+    const YGOverflow overflow)
+{
   updateStyle<MSVC_HINT(overflow)>(node, &YGStyle::overflow, overflow);
 }
-YOGA_EXPORT YGOverflow YGNodeStyleGetOverflow(const YGNodeConstRef node) {
+YOGA_EXPORT YGOverflow YGNodeStyleGetOverflow(const YGNodeConstRef node)
+{
   return node->getStyle().overflow();
 }
 
 YOGA_EXPORT void YGNodeStyleSetDisplay(
     const YGNodeRef node,
-    const YGDisplay display) {
+    const YGDisplay display)
+{
   updateStyle<MSVC_HINT(display)>(node, &YGStyle::display, display);
 }
-YOGA_EXPORT YGDisplay YGNodeStyleGetDisplay(const YGNodeConstRef node) {
+YOGA_EXPORT YGDisplay YGNodeStyleGetDisplay(const YGNodeConstRef node)
+{
   return node->getStyle().display();
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-YOGA_EXPORT void YGNodeStyleSetFlex(const YGNodeRef node, const float flex) {
+YOGA_EXPORT void YGNodeStyleSetFlex(const YGNodeRef node, const float flex)
+{
   updateStyle<MSVC_HINT(flex)>(node, &YGStyle::flex, YGFloatOptional{flex});
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-YOGA_EXPORT float YGNodeStyleGetFlex(const YGNodeConstRef node) {
+YOGA_EXPORT float YGNodeStyleGetFlex(const YGNodeConstRef node)
+{
   return node->getStyle().flex().isUndefined()
-      ? YGUndefined
-      : node->getStyle().flex().unwrap();
+             ? YGUndefined
+             : node->getStyle().flex().unwrap();
 }
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
 YOGA_EXPORT void YGNodeStyleSetFlexGrow(
     const YGNodeRef node,
-    const float flexGrow) {
+    const float flexGrow)
+{
   updateStyle<MSVC_HINT(flexGrow)>(
       node, &YGStyle::flexGrow, YGFloatOptional{flexGrow});
 }
@@ -677,14 +794,17 @@ YOGA_EXPORT void YGNodeStyleSetFlexGrow(
 // TODO(T26792433): Change the API to accept YGFloatOptional.
 YOGA_EXPORT void YGNodeStyleSetFlexShrink(
     const YGNodeRef node,
-    const float flexShrink) {
+    const float flexShrink)
+{
   updateStyle<MSVC_HINT(flexShrink)>(
       node, &YGStyle::flexShrink, YGFloatOptional{flexShrink});
 }
 
-YOGA_EXPORT YGValue YGNodeStyleGetFlexBasis(const YGNodeConstRef node) {
+YOGA_EXPORT YGValue YGNodeStyleGetFlexBasis(const YGNodeConstRef node)
+{
   YGValue flexBasis = node->getStyle().flexBasis();
-  if (flexBasis.unit == YGUnitUndefined || flexBasis.unit == YGUnitAuto) {
+  if (flexBasis.unit == YGUnitUndefined || flexBasis.unit == YGUnitAuto)
+  {
     // TODO(T26792433): Get rid off the use of YGUndefined at client side
     flexBasis.value = YGUndefined;
   }
@@ -693,19 +813,22 @@ YOGA_EXPORT YGValue YGNodeStyleGetFlexBasis(const YGNodeConstRef node) {
 
 YOGA_EXPORT void YGNodeStyleSetFlexBasis(
     const YGNodeRef node,
-    const float flexBasis) {
+    const float flexBasis)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(flexBasis);
   updateStyle<MSVC_HINT(flexBasis)>(node, &YGStyle::flexBasis, value);
 }
 
 YOGA_EXPORT void YGNodeStyleSetFlexBasisPercent(
     const YGNodeRef node,
-    const float flexBasisPercent) {
+    const float flexBasisPercent)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(flexBasisPercent);
   updateStyle<MSVC_HINT(flexBasis)>(node, &YGStyle::flexBasis, value);
 }
 
-YOGA_EXPORT void YGNodeStyleSetFlexBasisAuto(const YGNodeRef node) {
+YOGA_EXPORT void YGNodeStyleSetFlexBasisAuto(const YGNodeRef node)
+{
   updateStyle<MSVC_HINT(flexBasis)>(
       node, &YGStyle::flexBasis, detail::CompactValue::ofAuto());
 }
@@ -713,7 +836,8 @@ YOGA_EXPORT void YGNodeStyleSetFlexBasisAuto(const YGNodeRef node) {
 YOGA_EXPORT void YGNodeStyleSetPosition(
     YGNodeRef node,
     YGEdge edge,
-    float points) {
+    float points)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
   updateIndexedStyleProp<MSVC_HINT(position)>(
       node, &YGStyle::position, edge, value);
@@ -721,19 +845,22 @@ YOGA_EXPORT void YGNodeStyleSetPosition(
 YOGA_EXPORT void YGNodeStyleSetPositionPercent(
     YGNodeRef node,
     YGEdge edge,
-    float percent) {
+    float percent)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
   updateIndexedStyleProp<MSVC_HINT(position)>(
       node, &YGStyle::position, edge, value);
 }
-YOGA_EXPORT YGValue YGNodeStyleGetPosition(YGNodeConstRef node, YGEdge edge) {
+YOGA_EXPORT YGValue YGNodeStyleGetPosition(YGNodeConstRef node, YGEdge edge)
+{
   return node->getStyle().position()[edge];
 }
 
 YOGA_EXPORT void YGNodeStyleSetMargin(
     YGNodeRef node,
     YGEdge edge,
-    float points) {
+    float points)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
   updateIndexedStyleProp<MSVC_HINT(margin)>(
       node, &YGStyle::margin, edge, value);
@@ -741,23 +868,27 @@ YOGA_EXPORT void YGNodeStyleSetMargin(
 YOGA_EXPORT void YGNodeStyleSetMarginPercent(
     YGNodeRef node,
     YGEdge edge,
-    float percent) {
+    float percent)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
   updateIndexedStyleProp<MSVC_HINT(margin)>(
       node, &YGStyle::margin, edge, value);
 }
-YOGA_EXPORT void YGNodeStyleSetMarginAuto(YGNodeRef node, YGEdge edge) {
+YOGA_EXPORT void YGNodeStyleSetMarginAuto(YGNodeRef node, YGEdge edge)
+{
   updateIndexedStyleProp<MSVC_HINT(margin)>(
       node, &YGStyle::margin, edge, detail::CompactValue::ofAuto());
 }
-YOGA_EXPORT YGValue YGNodeStyleGetMargin(YGNodeConstRef node, YGEdge edge) {
+YOGA_EXPORT YGValue YGNodeStyleGetMargin(YGNodeConstRef node, YGEdge edge)
+{
   return node->getStyle().margin()[edge];
 }
 
 YOGA_EXPORT void YGNodeStyleSetPadding(
     YGNodeRef node,
     YGEdge edge,
-    float points) {
+    float points)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
   updateIndexedStyleProp<MSVC_HINT(padding)>(
       node, &YGStyle::padding, edge, value);
@@ -765,12 +896,14 @@ YOGA_EXPORT void YGNodeStyleSetPadding(
 YOGA_EXPORT void YGNodeStyleSetPaddingPercent(
     YGNodeRef node,
     YGEdge edge,
-    float percent) {
+    float percent)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
   updateIndexedStyleProp<MSVC_HINT(padding)>(
       node, &YGStyle::padding, edge, value);
 }
-YOGA_EXPORT YGValue YGNodeStyleGetPadding(YGNodeConstRef node, YGEdge edge) {
+YOGA_EXPORT YGValue YGNodeStyleGetPadding(YGNodeConstRef node, YGEdge edge)
+{
   return node->getStyle().padding()[edge];
 }
 
@@ -778,7 +911,8 @@ YOGA_EXPORT YGValue YGNodeStyleGetPadding(YGNodeConstRef node, YGEdge edge) {
 YOGA_EXPORT void YGNodeStyleSetBorder(
     const YGNodeRef node,
     const YGEdge edge,
-    const float border) {
+    const float border)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(border);
   updateIndexedStyleProp<MSVC_HINT(border)>(
       node, &YGStyle::border, edge, value);
@@ -786,9 +920,11 @@ YOGA_EXPORT void YGNodeStyleSetBorder(
 
 YOGA_EXPORT float YGNodeStyleGetBorder(
     const YGNodeConstRef node,
-    const YGEdge edge) {
+    const YGEdge edge)
+{
   auto border = node->getStyle().border()[edge];
-  if (border.isUndefined() || border.isAuto()) {
+  if (border.isUndefined() || border.isAuto())
+  {
     // TODO(T26792433): Rather than returning YGUndefined, change the api to
     // return YGFloatOptional.
     return YGUndefined;
@@ -800,16 +936,19 @@ YOGA_EXPORT float YGNodeStyleGetBorder(
 YOGA_EXPORT void YGNodeStyleSetGap(
     const YGNodeRef node,
     const YGGutter gutter,
-    const float gapLength) {
+    const float gapLength)
+{
   auto length = detail::CompactValue::ofMaybe<YGUnitPoint>(gapLength);
   updateIndexedStyleProp<MSVC_HINT(gap)>(node, &YGStyle::gap, gutter, length);
 }
 
 YOGA_EXPORT float YGNodeStyleGetGap(
     const YGNodeConstRef node,
-    const YGGutter gutter) {
+    const YGGutter gutter)
+{
   auto gapLength = node->getStyle().gap()[gutter];
-  if (gapLength.isUndefined() || gapLength.isAuto()) {
+  if (gapLength.isUndefined() || gapLength.isAuto())
+  {
     // TODO(T26792433): Rather than returning YGUndefined, change the api to
     // return YGFloatOptional.
     return YGUndefined;
@@ -821,7 +960,8 @@ YOGA_EXPORT float YGNodeStyleGetGap(
 // Yoga specific properties, not compatible with flexbox specification
 
 // TODO(T26792433): Change the API to accept YGFloatOptional.
-YOGA_EXPORT float YGNodeStyleGetAspectRatio(const YGNodeConstRef node) {
+YOGA_EXPORT float YGNodeStyleGetAspectRatio(const YGNodeConstRef node)
+{
   const YGFloatOptional op = node->getStyle().aspectRatio();
   return op.isUndefined() ? YGUndefined : op.unwrap();
 }
@@ -829,150 +969,181 @@ YOGA_EXPORT float YGNodeStyleGetAspectRatio(const YGNodeConstRef node) {
 // TODO(T26792433): Change the API to accept YGFloatOptional.
 YOGA_EXPORT void YGNodeStyleSetAspectRatio(
     const YGNodeRef node,
-    const float aspectRatio) {
+    const float aspectRatio)
+{
   updateStyle<MSVC_HINT(aspectRatio)>(
       node, &YGStyle::aspectRatio, YGFloatOptional{aspectRatio});
 }
 
-YOGA_EXPORT void YGNodeStyleSetWidth(YGNodeRef node, float points) {
+YOGA_EXPORT void YGNodeStyleSetWidth(YGNodeRef node, float points)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
   updateIndexedStyleProp<MSVC_HINT(dimensions)>(
       node, &YGStyle::dimensions, YGDimensionWidth, value);
 }
-YOGA_EXPORT void YGNodeStyleSetWidthPercent(YGNodeRef node, float percent) {
+YOGA_EXPORT void YGNodeStyleSetWidthPercent(YGNodeRef node, float percent)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
   updateIndexedStyleProp<MSVC_HINT(dimensions)>(
       node, &YGStyle::dimensions, YGDimensionWidth, value);
 }
-YOGA_EXPORT void YGNodeStyleSetWidthAuto(YGNodeRef node) {
+YOGA_EXPORT void YGNodeStyleSetWidthAuto(YGNodeRef node)
+{
   updateIndexedStyleProp<MSVC_HINT(dimensions)>(
       node,
       &YGStyle::dimensions,
       YGDimensionWidth,
       detail::CompactValue::ofAuto());
 }
-YOGA_EXPORT YGValue YGNodeStyleGetWidth(YGNodeConstRef node) {
+YOGA_EXPORT YGValue YGNodeStyleGetWidth(YGNodeConstRef node)
+{
   return node->getStyle().dimensions()[YGDimensionWidth];
 }
 
-YOGA_EXPORT void YGNodeStyleSetHeight(YGNodeRef node, float points) {
+YOGA_EXPORT void YGNodeStyleSetHeight(YGNodeRef node, float points)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(points);
   updateIndexedStyleProp<MSVC_HINT(dimensions)>(
       node, &YGStyle::dimensions, YGDimensionHeight, value);
 }
-YOGA_EXPORT void YGNodeStyleSetHeightPercent(YGNodeRef node, float percent) {
+YOGA_EXPORT void YGNodeStyleSetHeightPercent(YGNodeRef node, float percent)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(percent);
   updateIndexedStyleProp<MSVC_HINT(dimensions)>(
       node, &YGStyle::dimensions, YGDimensionHeight, value);
 }
-YOGA_EXPORT void YGNodeStyleSetHeightAuto(YGNodeRef node) {
+YOGA_EXPORT void YGNodeStyleSetHeightAuto(YGNodeRef node)
+{
   updateIndexedStyleProp<MSVC_HINT(dimensions)>(
       node,
       &YGStyle::dimensions,
       YGDimensionHeight,
       detail::CompactValue::ofAuto());
 }
-YOGA_EXPORT YGValue YGNodeStyleGetHeight(YGNodeConstRef node) {
+YOGA_EXPORT YGValue YGNodeStyleGetHeight(YGNodeConstRef node)
+{
   return node->getStyle().dimensions()[YGDimensionHeight];
 }
 
 YOGA_EXPORT void YGNodeStyleSetMinWidth(
     const YGNodeRef node,
-    const float minWidth) {
+    const float minWidth)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(minWidth);
   updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
       node, &YGStyle::minDimensions, YGDimensionWidth, value);
 }
 YOGA_EXPORT void YGNodeStyleSetMinWidthPercent(
     const YGNodeRef node,
-    const float minWidth) {
+    const float minWidth)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(minWidth);
   updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
       node, &YGStyle::minDimensions, YGDimensionWidth, value);
 }
-YOGA_EXPORT YGValue YGNodeStyleGetMinWidth(const YGNodeConstRef node) {
+YOGA_EXPORT YGValue YGNodeStyleGetMinWidth(const YGNodeConstRef node)
+{
   return node->getStyle().minDimensions()[YGDimensionWidth];
 };
 
 YOGA_EXPORT void YGNodeStyleSetMinHeight(
     const YGNodeRef node,
-    const float minHeight) {
+    const float minHeight)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(minHeight);
   updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
       node, &YGStyle::minDimensions, YGDimensionHeight, value);
 }
 YOGA_EXPORT void YGNodeStyleSetMinHeightPercent(
     const YGNodeRef node,
-    const float minHeight) {
+    const float minHeight)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(minHeight);
   updateIndexedStyleProp<MSVC_HINT(minDimensions)>(
       node, &YGStyle::minDimensions, YGDimensionHeight, value);
 }
-YOGA_EXPORT YGValue YGNodeStyleGetMinHeight(const YGNodeConstRef node) {
+YOGA_EXPORT YGValue YGNodeStyleGetMinHeight(const YGNodeConstRef node)
+{
   return node->getStyle().minDimensions()[YGDimensionHeight];
 };
 
 YOGA_EXPORT void YGNodeStyleSetMaxWidth(
     const YGNodeRef node,
-    const float maxWidth) {
+    const float maxWidth)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(maxWidth);
   updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
       node, &YGStyle::maxDimensions, YGDimensionWidth, value);
 }
 YOGA_EXPORT void YGNodeStyleSetMaxWidthPercent(
     const YGNodeRef node,
-    const float maxWidth) {
+    const float maxWidth)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(maxWidth);
   updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
       node, &YGStyle::maxDimensions, YGDimensionWidth, value);
 }
-YOGA_EXPORT YGValue YGNodeStyleGetMaxWidth(const YGNodeConstRef node) {
+YOGA_EXPORT YGValue YGNodeStyleGetMaxWidth(const YGNodeConstRef node)
+{
   return node->getStyle().maxDimensions()[YGDimensionWidth];
 };
 
 YOGA_EXPORT void YGNodeStyleSetMaxHeight(
     const YGNodeRef node,
-    const float maxHeight) {
+    const float maxHeight)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPoint>(maxHeight);
   updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
       node, &YGStyle::maxDimensions, YGDimensionHeight, value);
 }
 YOGA_EXPORT void YGNodeStyleSetMaxHeightPercent(
     const YGNodeRef node,
-    const float maxHeight) {
+    const float maxHeight)
+{
   auto value = detail::CompactValue::ofMaybe<YGUnitPercent>(maxHeight);
   updateIndexedStyleProp<MSVC_HINT(maxDimensions)>(
       node, &YGStyle::maxDimensions, YGDimensionHeight, value);
 }
-YOGA_EXPORT YGValue YGNodeStyleGetMaxHeight(const YGNodeConstRef node) {
+YOGA_EXPORT YGValue YGNodeStyleGetMaxHeight(const YGNodeConstRef node)
+{
   return node->getStyle().maxDimensions()[YGDimensionHeight];
 };
 
-#define YG_NODE_LAYOUT_PROPERTY_IMPL(type, name, instanceName)   \
-  YOGA_EXPORT type YGNodeLayoutGet##name(const YGNodeRef node) { \
-    return node->getLayout().instanceName;                       \
+#define YG_NODE_LAYOUT_PROPERTY_IMPL(type, name, instanceName) \
+  YOGA_EXPORT type YGNodeLayoutGet##name(const YGNodeRef node) \
+  {                                                            \
+    return node->getLayout().instanceName;                     \
   }
 
 #define YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(type, name, instanceName) \
   YOGA_EXPORT type YGNodeLayoutGet##name(                               \
-      const YGNodeRef node, const YGEdge edge) {                        \
+      const YGNodeRef node, const YGEdge edge)                          \
+  {                                                                     \
     YGAssertWithNode(                                                   \
         node,                                                           \
         edge <= YGEdgeEnd,                                              \
         "Cannot get layout properties of multi-edge shorthands");       \
                                                                         \
-    if (edge == YGEdgeStart) {                                          \
-      if (node->getLayout().direction() == YGDirectionRTL) {            \
+    if (edge == YGEdgeStart)                                            \
+    {                                                                   \
+      if (node->getLayout().direction() == YGDirectionRTL)              \
+      {                                                                 \
         return node->getLayout().instanceName[YGEdgeRight];             \
-      } else {                                                          \
+      }                                                                 \
+      else                                                              \
+      {                                                                 \
         return node->getLayout().instanceName[YGEdgeLeft];              \
       }                                                                 \
     }                                                                   \
                                                                         \
-    if (edge == YGEdgeEnd) {                                            \
-      if (node->getLayout().direction() == YGDirectionRTL) {            \
+    if (edge == YGEdgeEnd)                                              \
+    {                                                                   \
+      if (node->getLayout().direction() == YGDirectionRTL)              \
+      {                                                                 \
         return node->getLayout().instanceName[YGEdgeLeft];              \
-      } else {                                                          \
+      }                                                                 \
+      else                                                              \
+      {                                                                 \
         return node->getLayout().instanceName[YGEdgeRight];             \
       }                                                                 \
     }                                                                   \
@@ -994,7 +1165,8 @@ YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(float, Border, border);
 YG_NODE_LAYOUT_RESOLVED_PROPERTY_IMPL(float, Padding, padding);
 
 YOGA_EXPORT bool YGNodeLayoutGetDidLegacyStretchFlagAffectLayout(
-    const YGNodeRef node) {
+    const YGNodeRef node)
+{
   return node->getLayout().doesLegacyStretchFlagAffectsLayout();
 }
 
@@ -1012,15 +1184,16 @@ bool YGLayoutNodeInternal(
     const bool performLayout,
     const LayoutPassReason reason,
     const YGConfigRef config,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     const uint32_t depth,
     const uint32_t generationCount);
 
 #ifdef DEBUG
 static void YGNodePrintInternal(
     const YGNodeRef node,
-    const YGPrintOptions options) {
+    const YGPrintOptions options)
+{
   std::string str;
   facebook::yoga::YGNodeToString(str, node, options, 0);
   Log::log(node, YGLogLevelDebug, nullptr, str.c_str());
@@ -1028,7 +1201,8 @@ static void YGNodePrintInternal(
 
 YOGA_EXPORT void YGNodePrint(
     const YGNodeRef node,
-    const YGPrintOptions options) {
+    const YGPrintOptions options)
+{
   YGNodePrintInternal(node, options);
 }
 #endif
@@ -1051,25 +1225,30 @@ static const std::array<YGDimension, 4> dim = {
 static inline float YGNodePaddingAndBorderForAxis(
     const YGNodeConstRef node,
     const YGFlexDirection axis,
-    const float widthSize) {
+    const float widthSize)
+{
   return (node->getLeadingPaddingAndBorder(axis, widthSize) +
           node->getTrailingPaddingAndBorder(axis, widthSize))
       .unwrap();
 }
 
-static inline YGAlign YGNodeAlignItem(const YGNode* node, const YGNode* child) {
+static inline YGAlign YGNodeAlignItem(const YGNode *node, const YGNode *child)
+{
   const YGAlign align = child->getStyle().alignSelf() == YGAlignAuto
-      ? node->getStyle().alignItems()
-      : child->getStyle().alignSelf();
+                            ? node->getStyle().alignItems()
+                            : child->getStyle().alignSelf();
   if (align == YGAlignBaseline &&
-      YGFlexDirectionIsColumn(node->getStyle().flexDirection())) {
+      YGFlexDirectionIsColumn(node->getStyle().flexDirection()))
+  {
     return YGAlignFlexStart;
   }
   return align;
 }
 
-static float YGBaseline(const YGNodeRef node, void* layoutContext) {
-  if (node->hasBaselineFunc()) {
+static float YGBaseline(const YGNodeRef node, void *layoutContext)
+{
+  if (node->hasBaselineFunc())
+  {
 
     Event::publish<Event::NodeBaselineStart>(node);
 
@@ -1089,26 +1268,32 @@ static float YGBaseline(const YGNodeRef node, void* layoutContext) {
 
   YGNodeRef baselineChild = nullptr;
   const uint32_t childCount = YGNodeGetChildCount(node);
-  for (uint32_t i = 0; i < childCount; i++) {
+  for (uint32_t i = 0; i < childCount; i++)
+  {
     const YGNodeRef child = YGNodeGetChild(node, i);
-    if (child->getLineIndex() > 0) {
+    if (child->getLineIndex() > 0)
+    {
       break;
     }
-    if (child->getStyle().positionType() == YGPositionTypeAbsolute) {
+    if (child->getStyle().positionType() == YGPositionTypeAbsolute)
+    {
       continue;
     }
     if (YGNodeAlignItem(node, child) == YGAlignBaseline ||
-        child->isReferenceBaseline()) {
+        child->isReferenceBaseline())
+    {
       baselineChild = child;
       break;
     }
 
-    if (baselineChild == nullptr) {
+    if (baselineChild == nullptr)
+    {
       baselineChild = child;
     }
   }
 
-  if (baselineChild == nullptr) {
+  if (baselineChild == nullptr)
+  {
     return node->getLayout().measuredDimensions[YGDimensionHeight];
   }
 
@@ -1116,18 +1301,23 @@ static float YGBaseline(const YGNodeRef node, void* layoutContext) {
   return baseline + baselineChild->getLayout().position[YGEdgeTop];
 }
 
-static bool YGIsBaselineLayout(const YGNodeRef node) {
-  if (YGFlexDirectionIsColumn(node->getStyle().flexDirection())) {
+static bool YGIsBaselineLayout(const YGNodeRef node)
+{
+  if (YGFlexDirectionIsColumn(node->getStyle().flexDirection()))
+  {
     return false;
   }
-  if (node->getStyle().alignItems() == YGAlignBaseline) {
+  if (node->getStyle().alignItems() == YGAlignBaseline)
+  {
     return true;
   }
   const uint32_t childCount = YGNodeGetChildCount(node);
-  for (uint32_t i = 0; i < childCount; i++) {
+  for (uint32_t i = 0; i < childCount; i++)
+  {
     const YGNodeRef child = YGNodeGetChild(node, i);
     if (child->getStyle().positionType() != YGPositionTypeAbsolute &&
-        child->getStyle().alignSelf() == YGAlignBaseline) {
+        child->getStyle().alignSelf() == YGAlignBaseline)
+    {
       return true;
     }
   }
@@ -1138,17 +1328,19 @@ static bool YGIsBaselineLayout(const YGNodeRef node) {
 static inline float YGNodeDimWithMargin(
     const YGNodeRef node,
     const YGFlexDirection axis,
-    const float widthSize) {
+    const float widthSize)
+{
   return node->getLayout().measuredDimensions[dim[axis]] +
-      (node->getLeadingMargin(axis, widthSize) +
-       node->getTrailingMargin(axis, widthSize))
-          .unwrap();
+         (node->getLeadingMargin(axis, widthSize) +
+          node->getTrailingMargin(axis, widthSize))
+             .unwrap();
 }
 
 static inline bool YGNodeIsStyleDimDefined(
     const YGNodeRef node,
     const YGFlexDirection axis,
-    const float ownerSize) {
+    const float ownerSize)
+{
   bool isUndefined =
       YGFloatIsUndefined(node->getResolvedDimension(dim[axis]).value);
   return !(
@@ -1164,7 +1356,8 @@ static inline bool YGNodeIsStyleDimDefined(
 
 static inline bool YGNodeIsLayoutDimDefined(
     const YGNodeRef node,
-    const YGFlexDirection axis) {
+    const YGFlexDirection axis)
+{
   const float value = node->getLayout().measuredDimensions[dim[axis]];
   return !YGFloatIsUndefined(value) && value >= 0.0f;
 }
@@ -1173,27 +1366,33 @@ static YGFloatOptional YGNodeBoundAxisWithinMinAndMax(
     const YGNodeConstRef node,
     const YGFlexDirection axis,
     const YGFloatOptional value,
-    const float axisSize) {
+    const float axisSize)
+{
   YGFloatOptional min;
   YGFloatOptional max;
 
-  if (YGFlexDirectionIsColumn(axis)) {
+  if (YGFlexDirectionIsColumn(axis))
+  {
     min = YGResolveValue(
         node->getStyle().minDimensions()[YGDimensionHeight], axisSize);
     max = YGResolveValue(
         node->getStyle().maxDimensions()[YGDimensionHeight], axisSize);
-  } else if (YGFlexDirectionIsRow(axis)) {
+  }
+  else if (YGFlexDirectionIsRow(axis))
+  {
     min = YGResolveValue(
         node->getStyle().minDimensions()[YGDimensionWidth], axisSize);
     max = YGResolveValue(
         node->getStyle().maxDimensions()[YGDimensionWidth], axisSize);
   }
 
-  if (max >= YGFloatOptional{0} && value > max) {
+  if (max >= YGFloatOptional{0} && value > max)
+  {
     return max;
   }
 
-  if (min >= YGFloatOptional{0} && value < min) {
+  if (min >= YGFloatOptional{0} && value < min)
+  {
     return min;
   }
 
@@ -1207,7 +1406,8 @@ static inline float YGNodeBoundAxis(
     const YGFlexDirection axis,
     const float value,
     const float axisSize,
-    const float widthSize) {
+    const float widthSize)
+{
   return YGFloatMax(
       YGNodeBoundAxisWithinMinAndMax(
           node, axis, YGFloatOptional{value}, axisSize)
@@ -1218,7 +1418,8 @@ static inline float YGNodeBoundAxis(
 static void YGNodeSetChildTrailingPosition(
     const YGNodeRef node,
     const YGNodeRef child,
-    const YGFlexDirection axis) {
+    const YGFlexDirection axis)
+{
   const float size = child->getLayout().measuredDimensions[dim[axis]];
   child->setLayoutPosition(
       node->getLayout().measuredDimensions[dim[axis]] - size -
@@ -1231,25 +1432,28 @@ static void YGConstrainMaxSizeForMode(
     const enum YGFlexDirection axis,
     const float ownerAxisSize,
     const float ownerWidth,
-    YGMeasureMode* mode,
-    float* size) {
+    YGMeasureMode *mode,
+    float *size)
+{
   const YGFloatOptional maxSize =
       YGResolveValue(
           node->getStyle().maxDimensions()[dim[axis]], ownerAxisSize) +
       YGFloatOptional(node->getMarginForAxis(axis, ownerWidth));
-  switch (*mode) {
-    case YGMeasureModeExactly:
-    case YGMeasureModeAtMost:
-      *size = (maxSize.isUndefined() || *size < maxSize.unwrap())
-          ? *size
-          : maxSize.unwrap();
-      break;
-    case YGMeasureModeUndefined:
-      if (!maxSize.isUndefined()) {
-        *mode = YGMeasureModeAtMost;
-        *size = maxSize.unwrap();
-      }
-      break;
+  switch (*mode)
+  {
+  case YGMeasureModeExactly:
+  case YGMeasureModeAtMost:
+    *size = (maxSize.isUndefined() || *size < maxSize.unwrap())
+                ? *size
+                : maxSize.unwrap();
+    break;
+  case YGMeasureModeUndefined:
+    if (!maxSize.isUndefined())
+    {
+      *mode = YGMeasureModeAtMost;
+      *size = maxSize.unwrap();
+    }
+    break;
   }
 }
 
@@ -1264,10 +1468,11 @@ static void YGNodeComputeFlexBasisForChild(
     const YGMeasureMode heightMode,
     const YGDirection direction,
     const YGConfigRef config,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     const uint32_t depth,
-    const uint32_t generationCount) {
+    const uint32_t generationCount)
+{
   const YGFlexDirection mainAxis =
       YGResolveFlexDirection(node->getStyle().flexDirection(), direction);
   const bool isMainAxisRow = YGFlexDirectionIsRow(mainAxis);
@@ -1286,17 +1491,21 @@ static void YGNodeComputeFlexBasisForChild(
   const bool isColumnStyleDimDefined =
       YGNodeIsStyleDimDefined(child, YGFlexDirectionColumn, ownerHeight);
 
-  if (!resolvedFlexBasis.isUndefined() && !YGFloatIsUndefined(mainAxisSize)) {
+  if (!resolvedFlexBasis.isUndefined() && !YGFloatIsUndefined(mainAxisSize))
+  {
     if (child->getLayout().computedFlexBasis.isUndefined() ||
         (YGConfigIsExperimentalFeatureEnabled(
              child->getConfig(), YGExperimentalFeatureWebFlexBasis) &&
-         child->getLayout().computedFlexBasisGeneration != generationCount)) {
+         child->getLayout().computedFlexBasisGeneration != generationCount))
+    {
       const YGFloatOptional paddingAndBorder = YGFloatOptional(
           YGNodePaddingAndBorderForAxis(child, mainAxis, ownerWidth));
       child->setLayoutComputedFlexBasis(
           YGFloatOptionalMax(resolvedFlexBasis, paddingAndBorder));
     }
-  } else if (isMainAxisRow && isRowStyleDimDefined) {
+  }
+  else if (isMainAxisRow && isRowStyleDimDefined)
+  {
     // The width is definite, so use that as the flex basis.
     const YGFloatOptional paddingAndBorder = YGFloatOptional(
         YGNodePaddingAndBorderForAxis(child, YGFlexDirectionRow, ownerWidth));
@@ -1305,7 +1514,9 @@ static void YGNodeComputeFlexBasisForChild(
         YGResolveValue(
             child->getResolvedDimensions()[YGDimensionWidth], ownerWidth),
         paddingAndBorder));
-  } else if (!isMainAxisRow && isColumnStyleDimDefined) {
+  }
+  else if (!isMainAxisRow && isColumnStyleDimDefined)
+  {
     // The height is definite, so use that as the flex basis.
     const YGFloatOptional paddingAndBorder =
         YGFloatOptional(YGNodePaddingAndBorderForAxis(
@@ -1314,7 +1525,9 @@ static void YGNodeComputeFlexBasisForChild(
         YGResolveValue(
             child->getResolvedDimensions()[YGDimensionHeight], ownerHeight),
         paddingAndBorder));
-  } else {
+  }
+  else
+  {
     // Compute the flex basis and hypothetical main size (i.e. the clamped flex
     // basis).
     childWidth = YGUndefined;
@@ -1327,7 +1540,8 @@ static void YGNodeComputeFlexBasisForChild(
     auto marginColumn =
         child->getMarginForAxis(YGFlexDirectionColumn, ownerWidth).unwrap();
 
-    if (isRowStyleDimDefined) {
+    if (isRowStyleDimDefined)
+    {
       childWidth =
           YGResolveValue(
               child->getResolvedDimensions()[YGDimensionWidth], ownerWidth)
@@ -1335,7 +1549,8 @@ static void YGNodeComputeFlexBasisForChild(
           marginRow;
       childWidthMeasureMode = YGMeasureModeExactly;
     }
-    if (isColumnStyleDimDefined) {
+    if (isColumnStyleDimDefined)
+    {
       childHeight =
           YGResolveValue(
               child->getResolvedDimensions()[YGDimensionHeight], ownerHeight)
@@ -1347,31 +1562,39 @@ static void YGNodeComputeFlexBasisForChild(
     // The W3C spec doesn't say anything about the 'overflow' property, but all
     // major browsers appear to implement the following logic.
     if ((!isMainAxisRow && node->getStyle().overflow() == YGOverflowScroll) ||
-        node->getStyle().overflow() != YGOverflowScroll) {
-      if (YGFloatIsUndefined(childWidth) && !YGFloatIsUndefined(width)) {
+        node->getStyle().overflow() != YGOverflowScroll)
+    {
+      if (YGFloatIsUndefined(childWidth) && !YGFloatIsUndefined(width))
+      {
         childWidth = width;
         childWidthMeasureMode = YGMeasureModeAtMost;
       }
     }
 
     if ((isMainAxisRow && node->getStyle().overflow() == YGOverflowScroll) ||
-        node->getStyle().overflow() != YGOverflowScroll) {
-      if (YGFloatIsUndefined(childHeight) && !YGFloatIsUndefined(height)) {
+        node->getStyle().overflow() != YGOverflowScroll)
+    {
+      if (YGFloatIsUndefined(childHeight) && !YGFloatIsUndefined(height))
+      {
         childHeight = height;
         childHeightMeasureMode = YGMeasureModeAtMost;
       }
     }
 
-    const auto& childStyle = child->getStyle();
-    if (!childStyle.aspectRatio().isUndefined()) {
-      if (!isMainAxisRow && childWidthMeasureMode == YGMeasureModeExactly) {
+    const auto &childStyle = child->getStyle();
+    if (!childStyle.aspectRatio().isUndefined())
+    {
+      if (!isMainAxisRow && childWidthMeasureMode == YGMeasureModeExactly)
+      {
         childHeight = marginColumn +
-            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
+                      (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
         childHeightMeasureMode = YGMeasureModeExactly;
-      } else if (
-          isMainAxisRow && childHeightMeasureMode == YGMeasureModeExactly) {
+      }
+      else if (
+          isMainAxisRow && childHeightMeasureMode == YGMeasureModeExactly)
+      {
         childWidth = marginRow +
-            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
+                     (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
         childWidthMeasureMode = YGMeasureModeExactly;
       }
     }
@@ -1385,10 +1608,12 @@ static void YGNodeComputeFlexBasisForChild(
         YGNodeAlignItem(node, child) == YGAlignStretch &&
         childWidthMeasureMode != YGMeasureModeExactly;
     if (!isMainAxisRow && !isRowStyleDimDefined && hasExactWidth &&
-        childWidthStretch) {
+        childWidthStretch)
+    {
       childWidth = width;
       childWidthMeasureMode = YGMeasureModeExactly;
-      if (!childStyle.aspectRatio().isUndefined()) {
+      if (!childStyle.aspectRatio().isUndefined())
+      {
         childHeight =
             (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
         childHeightMeasureMode = YGMeasureModeExactly;
@@ -1401,11 +1626,13 @@ static void YGNodeComputeFlexBasisForChild(
         YGNodeAlignItem(node, child) == YGAlignStretch &&
         childHeightMeasureMode != YGMeasureModeExactly;
     if (isMainAxisRow && !isColumnStyleDimDefined && hasExactHeight &&
-        childHeightStretch) {
+        childHeightStretch)
+    {
       childHeight = height;
       childHeightMeasureMode = YGMeasureModeExactly;
 
-      if (!childStyle.aspectRatio().isUndefined()) {
+      if (!childStyle.aspectRatio().isUndefined())
+      {
         childWidth =
             (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
         childWidthMeasureMode = YGMeasureModeExactly;
@@ -1460,10 +1687,11 @@ static void YGNodeAbsoluteLayoutChild(
     const float height,
     const YGDirection direction,
     const YGConfigRef config,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     const uint32_t depth,
-    const uint32_t generationCount) {
+    const uint32_t generationCount)
+{
   const YGFlexDirection mainAxis =
       YGResolveFlexDirection(node->getStyle().flexDirection(), direction);
   const YGFlexDirection crossAxis = YGFlexDirectionCross(mainAxis, direction);
@@ -1478,43 +1706,51 @@ static void YGNodeAbsoluteLayoutChild(
   auto marginColumn =
       child->getMarginForAxis(YGFlexDirectionColumn, width).unwrap();
 
-  if (YGNodeIsStyleDimDefined(child, YGFlexDirectionRow, width)) {
+  if (YGNodeIsStyleDimDefined(child, YGFlexDirectionRow, width))
+  {
     childWidth =
         YGResolveValue(child->getResolvedDimensions()[YGDimensionWidth], width)
             .unwrap() +
         marginRow;
-  } else {
+  }
+  else
+  {
     // If the child doesn't have a specified width, compute the width based on
     // the left/right offsets if they're defined.
     if (child->isLeadingPositionDefined(YGFlexDirectionRow) &&
-        child->isTrailingPosDefined(YGFlexDirectionRow)) {
+        child->isTrailingPosDefined(YGFlexDirectionRow))
+    {
       childWidth = node->getLayout().measuredDimensions[YGDimensionWidth] -
-          (node->getLeadingBorder(YGFlexDirectionRow) +
-           node->getTrailingBorder(YGFlexDirectionRow)) -
-          (child->getLeadingPosition(YGFlexDirectionRow, width) +
-           child->getTrailingPosition(YGFlexDirectionRow, width))
-              .unwrap();
+                   (node->getLeadingBorder(YGFlexDirectionRow) +
+                    node->getTrailingBorder(YGFlexDirectionRow)) -
+                   (child->getLeadingPosition(YGFlexDirectionRow, width) +
+                    child->getTrailingPosition(YGFlexDirectionRow, width))
+                       .unwrap();
       childWidth =
           YGNodeBoundAxis(child, YGFlexDirectionRow, childWidth, width, width);
     }
   }
 
-  if (YGNodeIsStyleDimDefined(child, YGFlexDirectionColumn, height)) {
+  if (YGNodeIsStyleDimDefined(child, YGFlexDirectionColumn, height))
+  {
     childHeight = YGResolveValue(
                       child->getResolvedDimensions()[YGDimensionHeight], height)
                       .unwrap() +
-        marginColumn;
-  } else {
+                  marginColumn;
+  }
+  else
+  {
     // If the child doesn't have a specified height, compute the height based on
     // the top/bottom offsets if they're defined.
     if (child->isLeadingPositionDefined(YGFlexDirectionColumn) &&
-        child->isTrailingPosDefined(YGFlexDirectionColumn)) {
+        child->isTrailingPosDefined(YGFlexDirectionColumn))
+    {
       childHeight = node->getLayout().measuredDimensions[YGDimensionHeight] -
-          (node->getLeadingBorder(YGFlexDirectionColumn) +
-           node->getTrailingBorder(YGFlexDirectionColumn)) -
-          (child->getLeadingPosition(YGFlexDirectionColumn, height) +
-           child->getTrailingPosition(YGFlexDirectionColumn, height))
-              .unwrap();
+                    (node->getLeadingBorder(YGFlexDirectionColumn) +
+                     node->getTrailingBorder(YGFlexDirectionColumn)) -
+                    (child->getLeadingPosition(YGFlexDirectionColumn, height) +
+                     child->getTrailingPosition(YGFlexDirectionColumn, height))
+                        .unwrap();
       childHeight = YGNodeBoundAxis(
           child, YGFlexDirectionColumn, childHeight, height, width);
     }
@@ -1523,27 +1759,33 @@ static void YGNodeAbsoluteLayoutChild(
   // Exactly one dimension needs to be defined for us to be able to do aspect
   // ratio calculation. One dimension being the anchor and the other being
   // flexible.
-  const auto& childStyle = child->getStyle();
-  if (YGFloatIsUndefined(childWidth) ^ YGFloatIsUndefined(childHeight)) {
-    if (!childStyle.aspectRatio().isUndefined()) {
-      if (YGFloatIsUndefined(childWidth)) {
+  const auto &childStyle = child->getStyle();
+  if (YGFloatIsUndefined(childWidth) ^ YGFloatIsUndefined(childHeight))
+  {
+    if (!childStyle.aspectRatio().isUndefined())
+    {
+      if (YGFloatIsUndefined(childWidth))
+      {
         childWidth = marginRow +
-            (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
-      } else if (YGFloatIsUndefined(childHeight)) {
+                     (childHeight - marginColumn) * childStyle.aspectRatio().unwrap();
+      }
+      else if (YGFloatIsUndefined(childHeight))
+      {
         childHeight = marginColumn +
-            (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
+                      (childWidth - marginRow) / childStyle.aspectRatio().unwrap();
       }
     }
   }
 
   // If we're still missing one or the other dimension, measure the content.
-  if (YGFloatIsUndefined(childWidth) || YGFloatIsUndefined(childHeight)) {
+  if (YGFloatIsUndefined(childWidth) || YGFloatIsUndefined(childHeight))
+  {
     childWidthMeasureMode = YGFloatIsUndefined(childWidth)
-        ? YGMeasureModeUndefined
-        : YGMeasureModeExactly;
+                                ? YGMeasureModeUndefined
+                                : YGMeasureModeExactly;
     childHeightMeasureMode = YGFloatIsUndefined(childHeight)
-        ? YGMeasureModeUndefined
-        : YGMeasureModeExactly;
+                                 ? YGMeasureModeUndefined
+                                 : YGMeasureModeExactly;
 
     // If the size of the owner is defined then try to constrain the absolute
     // child to that size as well. This allows text within the absolute child to
@@ -1551,7 +1793,8 @@ static void YGNodeAbsoluteLayoutChild(
     // implement.
     if (!isMainAxisRow && YGFloatIsUndefined(childWidth) &&
         widthMode != YGMeasureModeUndefined && !YGFloatIsUndefined(width) &&
-        width > 0) {
+        width > 0)
+    {
       childWidth = width;
       childWidthMeasureMode = YGMeasureModeAtMost;
     }
@@ -1573,9 +1816,9 @@ static void YGNodeAbsoluteLayoutChild(
         depth,
         generationCount);
     childWidth = child->getLayout().measuredDimensions[YGDimensionWidth] +
-        child->getMarginForAxis(YGFlexDirectionRow, width).unwrap();
+                 child->getMarginForAxis(YGFlexDirectionRow, width).unwrap();
     childHeight = child->getLayout().measuredDimensions[YGDimensionHeight] +
-        child->getMarginForAxis(YGFlexDirectionColumn, width).unwrap();
+                  child->getMarginForAxis(YGFlexDirectionColumn, width).unwrap();
   }
 
   YGLayoutNodeInternal(
@@ -1596,7 +1839,8 @@ static void YGNodeAbsoluteLayoutChild(
       generationCount);
 
   if (child->isTrailingPosDefined(mainAxis) &&
-      !child->isLeadingPositionDefined(mainAxis)) {
+      !child->isLeadingPositionDefined(mainAxis))
+  {
     child->setLayoutPosition(
         node->getLayout().measuredDimensions[dim[mainAxis]] -
             child->getLayout().measuredDimensions[dim[mainAxis]] -
@@ -1605,17 +1849,21 @@ static void YGNodeAbsoluteLayoutChild(
             child->getTrailingPosition(mainAxis, isMainAxisRow ? width : height)
                 .unwrap(),
         leading[mainAxis]);
-  } else if (
+  }
+  else if (
       !child->isLeadingPositionDefined(mainAxis) &&
-      node->getStyle().justifyContent() == YGJustifyCenter) {
+      node->getStyle().justifyContent() == YGJustifyCenter)
+  {
     child->setLayoutPosition(
         (node->getLayout().measuredDimensions[dim[mainAxis]] -
          child->getLayout().measuredDimensions[dim[mainAxis]]) /
             2.0f,
         leading[mainAxis]);
-  } else if (
+  }
+  else if (
       !child->isLeadingPositionDefined(mainAxis) &&
-      node->getStyle().justifyContent() == YGJustifyFlexEnd) {
+      node->getStyle().justifyContent() == YGJustifyFlexEnd)
+  {
     child->setLayoutPosition(
         (node->getLayout().measuredDimensions[dim[mainAxis]] -
          child->getLayout().measuredDimensions[dim[mainAxis]]),
@@ -1623,7 +1871,8 @@ static void YGNodeAbsoluteLayoutChild(
   }
 
   if (child->isTrailingPosDefined(crossAxis) &&
-      !child->isLeadingPositionDefined(crossAxis)) {
+      !child->isLeadingPositionDefined(crossAxis))
+  {
     child->setLayoutPosition(
         node->getLayout().measuredDimensions[dim[crossAxis]] -
             child->getLayout().measuredDimensions[dim[crossAxis]] -
@@ -1633,19 +1882,22 @@ static void YGNodeAbsoluteLayoutChild(
                 ->getTrailingPosition(crossAxis, isMainAxisRow ? height : width)
                 .unwrap(),
         leading[crossAxis]);
-
-  } else if (
+  }
+  else if (
       !child->isLeadingPositionDefined(crossAxis) &&
-      YGNodeAlignItem(node, child) == YGAlignCenter) {
+      YGNodeAlignItem(node, child) == YGAlignCenter)
+  {
     child->setLayoutPosition(
         (node->getLayout().measuredDimensions[dim[crossAxis]] -
          child->getLayout().measuredDimensions[dim[crossAxis]]) /
             2.0f,
         leading[crossAxis]);
-  } else if (
+  }
+  else if (
       !child->isLeadingPositionDefined(crossAxis) &&
       ((YGNodeAlignItem(node, child) == YGAlignFlexEnd) ^
-       (node->getStyle().flexWrap() == YGWrapWrapReverse))) {
+       (node->getStyle().flexWrap() == YGWrapWrapReverse)))
+  {
     child->setLayoutPosition(
         (node->getLayout().measuredDimensions[dim[crossAxis]] -
          child->getLayout().measuredDimensions[dim[crossAxis]]),
@@ -1661,38 +1913,42 @@ static void YGNodeWithMeasureFuncSetMeasuredDimensions(
     const YGMeasureMode heightMeasureMode,
     const float ownerWidth,
     const float ownerHeight,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
-    const LayoutPassReason reason) {
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
+    const LayoutPassReason reason)
+{
   YGAssertWithNode(
       node,
       node->hasMeasureFunc(),
       "Expected node to have custom measure function");
 
-  if (widthMeasureMode == YGMeasureModeUndefined) {
+  if (widthMeasureMode == YGMeasureModeUndefined)
+  {
     availableWidth = YGUndefined;
   }
-  if (heightMeasureMode == YGMeasureModeUndefined) {
+  if (heightMeasureMode == YGMeasureModeUndefined)
+  {
     availableHeight = YGUndefined;
   }
 
-  const auto& padding = node->getLayout().padding;
-  const auto& border = node->getLayout().border;
+  const auto &padding = node->getLayout().padding;
+  const auto &border = node->getLayout().border;
   const float paddingAndBorderAxisRow = padding[YGEdgeLeft] +
-      padding[YGEdgeRight] + border[YGEdgeLeft] + border[YGEdgeRight];
+                                        padding[YGEdgeRight] + border[YGEdgeLeft] + border[YGEdgeRight];
   const float paddingAndBorderAxisColumn = padding[YGEdgeTop] +
-      padding[YGEdgeBottom] + border[YGEdgeTop] + border[YGEdgeBottom];
+                                           padding[YGEdgeBottom] + border[YGEdgeTop] + border[YGEdgeBottom];
 
   // We want to make sure we don't call measure with negative size
   const float innerWidth = YGFloatIsUndefined(availableWidth)
-      ? availableWidth
-      : YGFloatMax(0, availableWidth - paddingAndBorderAxisRow);
+                               ? availableWidth
+                               : YGFloatMax(0, availableWidth - paddingAndBorderAxisRow);
   const float innerHeight = YGFloatIsUndefined(availableHeight)
-      ? availableHeight
-      : YGFloatMax(0, availableHeight - paddingAndBorderAxisColumn);
+                                ? availableHeight
+                                : YGFloatMax(0, availableHeight - paddingAndBorderAxisColumn);
 
   if (widthMeasureMode == YGMeasureModeExactly &&
-      heightMeasureMode == YGMeasureModeExactly) {
+      heightMeasureMode == YGMeasureModeExactly)
+  {
     // Don't bother sizing the text if both dimensions are already defined.
     node->setLayoutMeasuredDimension(
         YGNodeBoundAxis(
@@ -1706,7 +1962,9 @@ static void YGNodeWithMeasureFuncSetMeasuredDimensions(
             ownerHeight,
             ownerWidth),
         YGDimensionHeight);
-  } else {
+  }
+  else
+  {
     Event::publish<Event::MeasureCallbackStart>(node);
 
     // Measure the text under the current constraints.
@@ -1767,15 +2025,17 @@ static void YGNodeEmptyContainerSetMeasuredDimensions(
     const YGMeasureMode widthMeasureMode,
     const YGMeasureMode heightMeasureMode,
     const float ownerWidth,
-    const float ownerHeight) {
-  const auto& padding = node->getLayout().padding;
-  const auto& border = node->getLayout().border;
+    const float ownerHeight)
+{
+  const auto &padding = node->getLayout().padding;
+  const auto &border = node->getLayout().border;
 
   float width = availableWidth;
   if (widthMeasureMode == YGMeasureModeUndefined ||
-      widthMeasureMode == YGMeasureModeAtMost) {
+      widthMeasureMode == YGMeasureModeAtMost)
+  {
     width = padding[YGEdgeLeft] + padding[YGEdgeRight] + border[YGEdgeLeft] +
-        border[YGEdgeRight];
+            border[YGEdgeRight];
   }
   node->setLayoutMeasuredDimension(
       YGNodeBoundAxis(node, YGFlexDirectionRow, width, ownerWidth, ownerWidth),
@@ -1783,9 +2043,10 @@ static void YGNodeEmptyContainerSetMeasuredDimensions(
 
   float height = availableHeight;
   if (heightMeasureMode == YGMeasureModeUndefined ||
-      heightMeasureMode == YGMeasureModeAtMost) {
+      heightMeasureMode == YGMeasureModeAtMost)
+  {
     height = padding[YGEdgeTop] + padding[YGEdgeBottom] + border[YGEdgeTop] +
-        border[YGEdgeBottom];
+             border[YGEdgeBottom];
   }
   node->setLayoutMeasuredDimension(
       YGNodeBoundAxis(
@@ -1800,13 +2061,15 @@ static bool YGNodeFixedSizeSetMeasuredDimensions(
     const YGMeasureMode widthMeasureMode,
     const YGMeasureMode heightMeasureMode,
     const float ownerWidth,
-    const float ownerHeight) {
+    const float ownerHeight)
+{
   if ((!YGFloatIsUndefined(availableWidth) &&
        widthMeasureMode == YGMeasureModeAtMost && availableWidth <= 0.0f) ||
       (!YGFloatIsUndefined(availableHeight) &&
        heightMeasureMode == YGMeasureModeAtMost && availableHeight <= 0.0f) ||
       (widthMeasureMode == YGMeasureModeExactly &&
-       heightMeasureMode == YGMeasureModeExactly)) {
+       heightMeasureMode == YGMeasureModeExactly))
+  {
     node->setLayoutMeasuredDimension(
         YGNodeBoundAxis(
             node,
@@ -1840,7 +2103,8 @@ static bool YGNodeFixedSizeSetMeasuredDimensions(
 
 static void YGZeroOutLayoutRecursivly(
     const YGNodeRef node,
-    void* layoutContext) {
+    void *layoutContext)
+{
   node->getLayout() = {};
   node->setLayoutDimension(0, 0);
   node->setLayoutDimension(0, 1);
@@ -1855,25 +2119,27 @@ static float YGNodeCalculateAvailableInnerDim(
     const YGDimension dimension,
     const float availableDim,
     const float paddingAndBorder,
-    const float ownerDim) {
+    const float ownerDim)
+{
   float availableInnerDim = availableDim - paddingAndBorder;
   // Max dimension overrides predefined dimension value; Min dimension in turn
   // overrides both of the above
-  if (!YGFloatIsUndefined(availableInnerDim)) {
+  if (!YGFloatIsUndefined(availableInnerDim))
+  {
     // We want to make sure our available height does not violate min and max
     // constraints
     const YGFloatOptional minDimensionOptional =
         YGResolveValue(node->getStyle().minDimensions()[dimension], ownerDim);
     const float minInnerDim = minDimensionOptional.isUndefined()
-        ? 0.0f
-        : minDimensionOptional.unwrap() - paddingAndBorder;
+                                  ? 0.0f
+                                  : minDimensionOptional.unwrap() - paddingAndBorder;
 
     const YGFloatOptional maxDimensionOptional =
         YGResolveValue(node->getStyle().maxDimensions()[dimension], ownerDim);
 
     const float maxInnerDim = maxDimensionOptional.isUndefined()
-        ? FLT_MAX
-        : maxDimensionOptional.unwrap() - paddingAndBorder;
+                                  ? FLT_MAX
+                                  : maxDimensionOptional.unwrap() - paddingAndBorder;
     availableInnerDim =
         YGFloatMax(YGFloatMin(availableInnerDim, maxInnerDim), minInnerDim);
   }
@@ -1891,63 +2157,77 @@ static float YGNodeComputeFlexBasisForChildren(
     YGFlexDirection mainAxis,
     const YGConfigRef config,
     bool performLayout,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     const uint32_t depth,
-    const uint32_t generationCount) {
+    const uint32_t generationCount)
+{
   float totalOuterFlexBasis = 0.0f;
   YGNodeRef singleFlexChild = nullptr;
-  const YGVector& children = node->getChildren();
+  const YGVector &children = node->getChildren();
   YGMeasureMode measureModeMainDim =
       YGFlexDirectionIsRow(mainAxis) ? widthMeasureMode : heightMeasureMode;
   // If there is only one child with flexGrow + flexShrink it means we can set
   // the computedFlexBasis to 0 instead of measuring and shrinking / flexing the
   // child to exactly match the remaining space
-  if (measureModeMainDim == YGMeasureModeExactly) {
-    for (auto child : children) {
-      if (child->isNodeFlexible()) {
+  if (measureModeMainDim == YGMeasureModeExactly)
+  {
+    for (auto child : children)
+    {
+      if (child->isNodeFlexible())
+      {
         if (singleFlexChild != nullptr ||
             YGFloatsEqual(child->resolveFlexGrow(), 0.0f) ||
-            YGFloatsEqual(child->resolveFlexShrink(), 0.0f)) {
+            YGFloatsEqual(child->resolveFlexShrink(), 0.0f))
+        {
           // There is already a flexible child, or this flexible child doesn't
           // have flexGrow and flexShrink, abort
           singleFlexChild = nullptr;
           break;
-        } else {
+        }
+        else
+        {
           singleFlexChild = child;
         }
       }
     }
   }
 
-  for (auto child : children) {
+  for (auto child : children)
+  {
     child->resolveDimension();
-    if (child->getStyle().display() == YGDisplayNone) {
+    if (child->getStyle().display() == YGDisplayNone)
+    {
       YGZeroOutLayoutRecursivly(child, layoutContext);
       child->setHasNewLayout(true);
       child->setDirty(false);
       continue;
     }
-    if (performLayout) {
+    if (performLayout)
+    {
       // Set the initial position (relative to the owner).
       const YGDirection childDirection = child->resolveDirection(direction);
       const float mainDim = YGFlexDirectionIsRow(mainAxis)
-          ? availableInnerWidth
-          : availableInnerHeight;
+                                ? availableInnerWidth
+                                : availableInnerHeight;
       const float crossDim = YGFlexDirectionIsRow(mainAxis)
-          ? availableInnerHeight
-          : availableInnerWidth;
+                                 ? availableInnerHeight
+                                 : availableInnerWidth;
       child->setPosition(
           childDirection, mainDim, crossDim, availableInnerWidth);
     }
 
-    if (child->getStyle().positionType() == YGPositionTypeAbsolute) {
+    if (child->getStyle().positionType() == YGPositionTypeAbsolute)
+    {
       continue;
     }
-    if (child == singleFlexChild) {
+    if (child == singleFlexChild)
+    {
       child->setLayoutComputedFlexBasisGeneration(generationCount);
       child->setLayoutComputedFlexBasis(YGFloatOptional(0));
-    } else {
+    }
+    else
+    {
       YGNodeComputeFlexBasisForChild(
           node,
           child,
@@ -1979,13 +2259,14 @@ static float YGNodeComputeFlexBasisForChildren(
 // YGNodeComputeFlexBasisForChildren function). This function calculates
 // YGCollectFlexItemsRowMeasurement
 static YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(
-    const YGNodeRef& node,
+    const YGNodeRef &node,
     const YGDirection ownerDirection,
     const float mainAxisownerSize,
     const float availableInnerWidth,
     const float availableInnerMainDim,
     const uint32_t startOfLineIndex,
-    const uint32_t lineCount) {
+    const uint32_t lineCount)
+{
   YGCollectFlexItemsRowValues flexAlgoRowMeasurement = {};
   flexAlgoRowMeasurement.relativeChildren.reserve(node->getChildren().size());
 
@@ -1997,10 +2278,12 @@ static YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(
 
   // Add items to the current line until it's full or we run out of items.
   uint32_t endOfLineIndex = startOfLineIndex;
-  for (; endOfLineIndex < node->getChildren().size(); endOfLineIndex++) {
+  for (; endOfLineIndex < node->getChildren().size(); endOfLineIndex++)
+  {
     const YGNodeRef child = node->getChild(endOfLineIndex);
     if (child->getStyle().display() == YGDisplayNone ||
-        child->getStyle().positionType() == YGPositionTypeAbsolute) {
+        child->getStyle().positionType() == YGPositionTypeAbsolute)
+    {
       continue;
     }
 
@@ -2025,7 +2308,8 @@ static YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(
                 flexBasisWithMinAndMaxConstraints + childMarginMainAxis +
                 childLeadingGapMainAxis >
             availableInnerMainDim &&
-        isNodeFlexWrap && flexAlgoRowMeasurement.itemsOnLine > 0) {
+        isNodeFlexWrap && flexAlgoRowMeasurement.itemsOnLine > 0)
+    {
       break;
     }
 
@@ -2037,7 +2321,8 @@ static YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(
         childLeadingGapMainAxis;
     flexAlgoRowMeasurement.itemsOnLine++;
 
-    if (child->isNodeFlexible()) {
+    if (child->isNodeFlexible())
+    {
       flexAlgoRowMeasurement.totalFlexGrowFactors += child->resolveFlexGrow();
 
       // Unlike the grow factor, the shrink factor is scaled relative to the
@@ -2052,13 +2337,15 @@ static YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(
 
   // The total flex factor needs to be floored to 1.
   if (flexAlgoRowMeasurement.totalFlexGrowFactors > 0 &&
-      flexAlgoRowMeasurement.totalFlexGrowFactors < 1) {
+      flexAlgoRowMeasurement.totalFlexGrowFactors < 1)
+  {
     flexAlgoRowMeasurement.totalFlexGrowFactors = 1;
   }
 
   // The total flex shrink factor needs to be floored to 1.
   if (flexAlgoRowMeasurement.totalFlexShrinkScaledFactors > 0 &&
-      flexAlgoRowMeasurement.totalFlexShrinkScaledFactors < 1) {
+      flexAlgoRowMeasurement.totalFlexShrinkScaledFactors < 1)
+  {
     flexAlgoRowMeasurement.totalFlexShrinkScaledFactors = 1;
   }
   flexAlgoRowMeasurement.endOfLineIndex = endOfLineIndex;
@@ -2070,7 +2357,7 @@ static YGCollectFlexItemsRowValues YGCalculateCollectFlexItemsRowValues(
 // function the child nodes would have proper size. Prior using this function
 // please ensure that YGDistributeFreeSpaceFirstPass is called.
 static float YGDistributeFreeSpaceSecondPass(
-    YGCollectFlexItemsRowValues& collectedFlexItemsValues,
+    YGCollectFlexItemsRowValues &collectedFlexItemsValues,
     const YGNodeRef node,
     const YGFlexDirection mainAxis,
     const YGFlexDirection crossAxis,
@@ -2083,10 +2370,11 @@ static float YGDistributeFreeSpaceSecondPass(
     const YGMeasureMode measureModeCrossDim,
     const bool performLayout,
     const YGConfigRef config,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     const uint32_t depth,
-    const uint32_t generationCount) {
+    const uint32_t generationCount)
+{
   float childFlexBasis = 0;
   float flexShrinkScaledFactor = 0;
   float flexGrowFactor = 0;
@@ -2094,7 +2382,8 @@ static float YGDistributeFreeSpaceSecondPass(
   const bool isMainAxisRow = YGFlexDirectionIsRow(mainAxis);
   const bool isNodeFlexWrap = node->getStyle().flexWrap() != YGWrapNoWrap;
 
-  for (auto currentRelativeChild : collectedFlexItemsValues.relativeChildren) {
+  for (auto currentRelativeChild : collectedFlexItemsValues.relativeChildren)
+  {
     childFlexBasis = YGNodeBoundAxisWithinMinAndMax(
                          currentRelativeChild,
                          mainAxis,
@@ -2104,22 +2393,27 @@ static float YGDistributeFreeSpaceSecondPass(
     float updatedMainSize = childFlexBasis;
 
     if (!YGFloatIsUndefined(collectedFlexItemsValues.remainingFreeSpace) &&
-        collectedFlexItemsValues.remainingFreeSpace < 0) {
+        collectedFlexItemsValues.remainingFreeSpace < 0)
+    {
       flexShrinkScaledFactor =
           -currentRelativeChild->resolveFlexShrink() * childFlexBasis;
       // Is this child able to shrink?
-      if (flexShrinkScaledFactor != 0) {
+      if (flexShrinkScaledFactor != 0)
+      {
         float childSize;
 
         if (!YGFloatIsUndefined(
                 collectedFlexItemsValues.totalFlexShrinkScaledFactors) &&
-            collectedFlexItemsValues.totalFlexShrinkScaledFactors == 0) {
+            collectedFlexItemsValues.totalFlexShrinkScaledFactors == 0)
+        {
           childSize = childFlexBasis + flexShrinkScaledFactor;
-        } else {
+        }
+        else
+        {
           childSize = childFlexBasis +
-              (collectedFlexItemsValues.remainingFreeSpace /
-               collectedFlexItemsValues.totalFlexShrinkScaledFactors) *
-                  flexShrinkScaledFactor;
+                      (collectedFlexItemsValues.remainingFreeSpace /
+                       collectedFlexItemsValues.totalFlexShrinkScaledFactors) *
+                          flexShrinkScaledFactor;
         }
 
         updatedMainSize = YGNodeBoundAxis(
@@ -2129,13 +2423,16 @@ static float YGDistributeFreeSpaceSecondPass(
             availableInnerMainDim,
             availableInnerWidth);
       }
-    } else if (
+    }
+    else if (
         !YGFloatIsUndefined(collectedFlexItemsValues.remainingFreeSpace) &&
-        collectedFlexItemsValues.remainingFreeSpace > 0) {
+        collectedFlexItemsValues.remainingFreeSpace > 0)
+    {
       flexGrowFactor = currentRelativeChild->resolveFlexGrow();
 
       // Is this child able to grow?
-      if (!YGFloatIsUndefined(flexGrowFactor) && flexGrowFactor != 0) {
+      if (!YGFloatIsUndefined(flexGrowFactor) && flexGrowFactor != 0)
+      {
         updatedMainSize = YGNodeBoundAxis(
             currentRelativeChild,
             mainAxis,
@@ -2162,15 +2459,17 @@ static float YGDistributeFreeSpaceSecondPass(
     YGMeasureMode childCrossMeasureMode;
     YGMeasureMode childMainMeasureMode = YGMeasureModeExactly;
 
-    const auto& childStyle = currentRelativeChild->getStyle();
-    if (!childStyle.aspectRatio().isUndefined()) {
+    const auto &childStyle = currentRelativeChild->getStyle();
+    if (!childStyle.aspectRatio().isUndefined())
+    {
       childCrossSize = isMainAxisRow
-          ? (childMainSize - marginMain) / childStyle.aspectRatio().unwrap()
-          : (childMainSize - marginMain) * childStyle.aspectRatio().unwrap();
+                           ? (childMainSize - marginMain) / childStyle.aspectRatio().unwrap()
+                           : (childMainSize - marginMain) * childStyle.aspectRatio().unwrap();
       childCrossMeasureMode = YGMeasureModeExactly;
 
       childCrossSize += marginCross;
-    } else if (
+    }
+    else if (
         !YGFloatIsUndefined(availableInnerCrossDim) &&
         !YGNodeIsStyleDimDefined(
             currentRelativeChild, crossAxis, availableInnerCrossDim) &&
@@ -2180,16 +2479,21 @@ static float YGDistributeFreeSpaceSecondPass(
         currentRelativeChild->marginLeadingValue(crossAxis).unit !=
             YGUnitAuto &&
         currentRelativeChild->marginTrailingValue(crossAxis).unit !=
-            YGUnitAuto) {
+            YGUnitAuto)
+    {
       childCrossSize = availableInnerCrossDim;
       childCrossMeasureMode = YGMeasureModeExactly;
-    } else if (!YGNodeIsStyleDimDefined(
-                   currentRelativeChild, crossAxis, availableInnerCrossDim)) {
+    }
+    else if (!YGNodeIsStyleDimDefined(
+                 currentRelativeChild, crossAxis, availableInnerCrossDim))
+    {
       childCrossSize = availableInnerCrossDim;
       childCrossMeasureMode = YGFloatIsUndefined(childCrossSize)
-          ? YGMeasureModeUndefined
-          : YGMeasureModeAtMost;
-    } else {
+                                  ? YGMeasureModeUndefined
+                                  : YGMeasureModeAtMost;
+    }
+    else
+    {
       childCrossSize =
           YGResolveValue(
               currentRelativeChild->getResolvedDimension(dim[crossAxis]),
@@ -2202,8 +2506,8 @@ static float YGDistributeFreeSpaceSecondPass(
           measureModeCrossDim != YGMeasureModeExactly;
       childCrossMeasureMode =
           YGFloatIsUndefined(childCrossSize) || isLoosePercentageMeasurement
-          ? YGMeasureModeUndefined
-          : YGMeasureModeExactly;
+              ? YGMeasureModeUndefined
+              : YGMeasureModeExactly;
     }
 
     YGConstrainMaxSizeForMode(
@@ -2268,18 +2572,20 @@ static float YGDistributeFreeSpaceSecondPass(
 // whose min and max constraints are triggered, those flex item's clamped size
 // is removed from the remaingfreespace.
 static void YGDistributeFreeSpaceFirstPass(
-    YGCollectFlexItemsRowValues& collectedFlexItemsValues,
+    YGCollectFlexItemsRowValues &collectedFlexItemsValues,
     const YGFlexDirection mainAxis,
     const float mainAxisownerSize,
     const float availableInnerMainDim,
-    const float availableInnerWidth) {
+    const float availableInnerWidth)
+{
   float flexShrinkScaledFactor = 0;
   float flexGrowFactor = 0;
   float baseMainSize = 0;
   float boundMainSize = 0;
   float deltaFreeSpace = 0;
 
-  for (auto currentRelativeChild : collectedFlexItemsValues.relativeChildren) {
+  for (auto currentRelativeChild : collectedFlexItemsValues.relativeChildren)
+  {
     float childFlexBasis =
         YGNodeBoundAxisWithinMinAndMax(
             currentRelativeChild,
@@ -2288,17 +2594,19 @@ static void YGDistributeFreeSpaceFirstPass(
             mainAxisownerSize)
             .unwrap();
 
-    if (collectedFlexItemsValues.remainingFreeSpace < 0) {
+    if (collectedFlexItemsValues.remainingFreeSpace < 0)
+    {
       flexShrinkScaledFactor =
           -currentRelativeChild->resolveFlexShrink() * childFlexBasis;
 
       // Is this child able to shrink?
       if (!YGFloatIsUndefined(flexShrinkScaledFactor) &&
-          flexShrinkScaledFactor != 0) {
+          flexShrinkScaledFactor != 0)
+      {
         baseMainSize = childFlexBasis +
-            collectedFlexItemsValues.remainingFreeSpace /
-                collectedFlexItemsValues.totalFlexShrinkScaledFactors *
-                flexShrinkScaledFactor;
+                       collectedFlexItemsValues.remainingFreeSpace /
+                           collectedFlexItemsValues.totalFlexShrinkScaledFactors *
+                           flexShrinkScaledFactor;
         boundMainSize = YGNodeBoundAxis(
             currentRelativeChild,
             mainAxis,
@@ -2307,7 +2615,8 @@ static void YGDistributeFreeSpaceFirstPass(
             availableInnerWidth);
         if (!YGFloatIsUndefined(baseMainSize) &&
             !YGFloatIsUndefined(boundMainSize) &&
-            baseMainSize != boundMainSize) {
+            baseMainSize != boundMainSize)
+        {
           // By excluding this item's size and flex factor from remaining, this
           // item's min/max constraints should also trigger in the second pass
           // resulting in the item's size calculation being identical in the
@@ -2318,16 +2627,19 @@ static void YGDistributeFreeSpaceFirstPass(
                currentRelativeChild->getLayout().computedFlexBasis.unwrap());
         }
       }
-    } else if (
+    }
+    else if (
         !YGFloatIsUndefined(collectedFlexItemsValues.remainingFreeSpace) &&
-        collectedFlexItemsValues.remainingFreeSpace > 0) {
+        collectedFlexItemsValues.remainingFreeSpace > 0)
+    {
       flexGrowFactor = currentRelativeChild->resolveFlexGrow();
 
       // Is this child able to grow?
-      if (!YGFloatIsUndefined(flexGrowFactor) && flexGrowFactor != 0) {
+      if (!YGFloatIsUndefined(flexGrowFactor) && flexGrowFactor != 0)
+      {
         baseMainSize = childFlexBasis +
-            collectedFlexItemsValues.remainingFreeSpace /
-                collectedFlexItemsValues.totalFlexGrowFactors * flexGrowFactor;
+                       collectedFlexItemsValues.remainingFreeSpace /
+                           collectedFlexItemsValues.totalFlexGrowFactors * flexGrowFactor;
         boundMainSize = YGNodeBoundAxis(
             currentRelativeChild,
             mainAxis,
@@ -2337,7 +2649,8 @@ static void YGDistributeFreeSpaceFirstPass(
 
         if (!YGFloatIsUndefined(baseMainSize) &&
             !YGFloatIsUndefined(boundMainSize) &&
-            baseMainSize != boundMainSize) {
+            baseMainSize != boundMainSize)
+        {
           // By excluding this item's size and flex factor from remaining, this
           // item's min/max constraints should also trigger in the second pass
           // resulting in the item's size calculation being identical in the
@@ -2375,7 +2688,7 @@ static void YGDistributeFreeSpaceFirstPass(
 //
 static void YGResolveFlexibleLength(
     const YGNodeRef node,
-    YGCollectFlexItemsRowValues& collectedFlexItemsValues,
+    YGCollectFlexItemsRowValues &collectedFlexItemsValues,
     const YGFlexDirection mainAxis,
     const YGFlexDirection crossAxis,
     const float mainAxisownerSize,
@@ -2387,10 +2700,11 @@ static void YGResolveFlexibleLength(
     const YGMeasureMode measureModeCrossDim,
     const bool performLayout,
     const YGConfigRef config,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     const uint32_t depth,
-    const uint32_t generationCount) {
+    const uint32_t generationCount)
+{
   const float originalFreeSpace = collectedFlexItemsValues.remainingFreeSpace;
   // First pass: detect the flex items whose min/max constraints trigger
   YGDistributeFreeSpaceFirstPass(
@@ -2426,7 +2740,7 @@ static void YGResolveFlexibleLength(
 
 static void YGJustifyMainAxis(
     const YGNodeRef node,
-    YGCollectFlexItemsRowValues& collectedFlexItemsValues,
+    YGCollectFlexItemsRowValues &collectedFlexItemsValues,
     const uint32_t startOfLineIndex,
     const YGFlexDirection mainAxis,
     const YGFlexDirection crossAxis,
@@ -2438,8 +2752,9 @@ static void YGJustifyMainAxis(
     const float availableInnerCrossDim,
     const float availableInnerWidth,
     const bool performLayout,
-    void* const layoutContext) {
-  const auto& style = node->getStyle();
+    void *const layoutContext)
+{
+  const auto &style = node->getStyle();
   const float leadingPaddingAndBorderMain =
       node->getLeadingPaddingAndBorder(mainAxis, ownerWidth).unwrap();
   const float trailingPaddingAndBorderMain =
@@ -2448,10 +2763,12 @@ static void YGJustifyMainAxis(
   // If we are using "at most" rules in the main axis, make sure that
   // remainingFreeSpace is 0 when min main dimension is not given
   if (measureModeMainDim == YGMeasureModeAtMost &&
-      collectedFlexItemsValues.remainingFreeSpace > 0) {
+      collectedFlexItemsValues.remainingFreeSpace > 0)
+  {
     if (!style.minDimensions()[dim[mainAxis]].isUndefined() &&
         !YGResolveValue(style.minDimensions()[dim[mainAxis]], mainAxisownerSize)
-             .isUndefined()) {
+             .isUndefined())
+    {
       // This condition makes sure that if the size of main dimension(after
       // considering child nodes main dim, leading and trailing padding etc)
       // falls below min dimension, then the remainingFreeSpace is reassigned
@@ -2468,7 +2785,9 @@ static void YGJustifyMainAxis(
           availableInnerMainDim - collectedFlexItemsValues.remainingFreeSpace;
       collectedFlexItemsValues.remainingFreeSpace =
           YGFloatMax(0, minAvailableMainDim - occupiedSpaceByChildNodes);
-    } else {
+    }
+    else
+    {
       collectedFlexItemsValues.remainingFreeSpace = 0;
     }
   }
@@ -2476,13 +2795,17 @@ static void YGJustifyMainAxis(
   int numberOfAutoMarginsOnCurrentLine = 0;
   for (uint32_t i = startOfLineIndex;
        i < collectedFlexItemsValues.endOfLineIndex;
-       i++) {
+       i++)
+  {
     const YGNodeRef child = node->getChild(i);
-    if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
-      if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto) {
+    if (child->getStyle().positionType() != YGPositionTypeAbsolute)
+    {
+      if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto)
+      {
         numberOfAutoMarginsOnCurrentLine++;
       }
-      if (child->marginTrailingValue(mainAxis).unit == YGUnitAuto) {
+      if (child->marginTrailingValue(mainAxis).unit == YGUnitAuto)
+      {
         numberOfAutoMarginsOnCurrentLine++;
       }
     }
@@ -2495,35 +2818,38 @@ static void YGJustifyMainAxis(
   float betweenMainDim = gap;
   const YGJustify justifyContent = node->getStyle().justifyContent();
 
-  if (numberOfAutoMarginsOnCurrentLine == 0) {
-    switch (justifyContent) {
-      case YGJustifyCenter:
-        leadingMainDim = collectedFlexItemsValues.remainingFreeSpace / 2;
-        break;
-      case YGJustifyFlexEnd:
-        leadingMainDim = collectedFlexItemsValues.remainingFreeSpace;
-        break;
-      case YGJustifySpaceBetween:
-        if (collectedFlexItemsValues.itemsOnLine > 1) {
-          betweenMainDim +=
-              YGFloatMax(collectedFlexItemsValues.remainingFreeSpace, 0) /
-              (collectedFlexItemsValues.itemsOnLine - 1);
-        }
-        break;
-      case YGJustifySpaceEvenly:
-        // Space is distributed evenly across all elements
-        leadingMainDim = collectedFlexItemsValues.remainingFreeSpace /
-            (collectedFlexItemsValues.itemsOnLine + 1);
-        betweenMainDim += leadingMainDim;
-        break;
-      case YGJustifySpaceAround:
-        // Space on the edges is half of the space between elements
-        leadingMainDim = 0.5f * collectedFlexItemsValues.remainingFreeSpace /
-            collectedFlexItemsValues.itemsOnLine;
-        betweenMainDim += leadingMainDim * 2;
-        break;
-      case YGJustifyFlexStart:
-        break;
+  if (numberOfAutoMarginsOnCurrentLine == 0)
+  {
+    switch (justifyContent)
+    {
+    case YGJustifyCenter:
+      leadingMainDim = collectedFlexItemsValues.remainingFreeSpace / 2;
+      break;
+    case YGJustifyFlexEnd:
+      leadingMainDim = collectedFlexItemsValues.remainingFreeSpace;
+      break;
+    case YGJustifySpaceBetween:
+      if (collectedFlexItemsValues.itemsOnLine > 1)
+      {
+        betweenMainDim +=
+            YGFloatMax(collectedFlexItemsValues.remainingFreeSpace, 0) /
+            (collectedFlexItemsValues.itemsOnLine - 1);
+      }
+      break;
+    case YGJustifySpaceEvenly:
+      // Space is distributed evenly across all elements
+      leadingMainDim = collectedFlexItemsValues.remainingFreeSpace /
+                       (collectedFlexItemsValues.itemsOnLine + 1);
+      betweenMainDim += leadingMainDim;
+      break;
+    case YGJustifySpaceAround:
+      // Space on the edges is half of the space between elements
+      leadingMainDim = 0.5f * collectedFlexItemsValues.remainingFreeSpace /
+                       collectedFlexItemsValues.itemsOnLine;
+      betweenMainDim += leadingMainDim * 2;
+      break;
+    case YGJustifyFlexStart:
+      break;
     }
   }
 
@@ -2536,21 +2862,26 @@ static void YGJustifyMainAxis(
   bool isNodeBaselineLayout = YGIsBaselineLayout(node);
   for (uint32_t i = startOfLineIndex;
        i < collectedFlexItemsValues.endOfLineIndex;
-       i++) {
+       i++)
+  {
     const YGNodeRef child = node->getChild(i);
-    const YGStyle& childStyle = child->getStyle();
+    const YGStyle &childStyle = child->getStyle();
     const YGLayout childLayout = child->getLayout();
     const bool isLastChild = i == collectedFlexItemsValues.endOfLineIndex - 1;
     // remove the gap if it is the last element of the line
-    if (isLastChild) {
+    if (isLastChild)
+    {
       betweenMainDim -= gap;
     }
-    if (childStyle.display() == YGDisplayNone) {
+    if (childStyle.display() == YGDisplayNone)
+    {
       continue;
     }
     if (childStyle.positionType() == YGPositionTypeAbsolute &&
-        child->isLeadingPositionDefined(mainAxis)) {
-      if (performLayout) {
+        child->isLeadingPositionDefined(mainAxis))
+    {
+      if (performLayout)
+      {
         // In case the child is position absolute and has left/top being
         // defined, we override the position to whatever the user said (and
         // margin/border).
@@ -2561,53 +2892,63 @@ static void YGJustifyMainAxis(
                 child->getLeadingMargin(mainAxis, availableInnerWidth).unwrap(),
             pos[mainAxis]);
       }
-    } else {
+    }
+    else
+    {
       // Now that we placed the element, we need to update the variables.
       // We need to do that only for relative elements. Absolute elements do not
       // take part in that phase.
-      if (childStyle.positionType() != YGPositionTypeAbsolute) {
-        if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto) {
+      if (childStyle.positionType() != YGPositionTypeAbsolute)
+      {
+        if (child->marginLeadingValue(mainAxis).unit == YGUnitAuto)
+        {
           collectedFlexItemsValues.mainDim +=
               collectedFlexItemsValues.remainingFreeSpace /
               numberOfAutoMarginsOnCurrentLine;
         }
 
-        if (performLayout) {
+        if (performLayout)
+        {
           child->setLayoutPosition(
               childLayout.position[pos[mainAxis]] +
                   collectedFlexItemsValues.mainDim,
               pos[mainAxis]);
         }
 
-        if (child->marginTrailingValue(mainAxis).unit == YGUnitAuto) {
+        if (child->marginTrailingValue(mainAxis).unit == YGUnitAuto)
+        {
           collectedFlexItemsValues.mainDim +=
               collectedFlexItemsValues.remainingFreeSpace /
               numberOfAutoMarginsOnCurrentLine;
         }
         bool canSkipFlex =
             !performLayout && measureModeCrossDim == YGMeasureModeExactly;
-        if (canSkipFlex) {
+        if (canSkipFlex)
+        {
           // If we skipped the flex step, then we can't rely on the measuredDims
           // because they weren't computed. This means we can't call
           // YGNodeDimWithMargin.
           collectedFlexItemsValues.mainDim += betweenMainDim +
-              child->getMarginForAxis(mainAxis, availableInnerWidth).unwrap() +
-              childLayout.computedFlexBasis.unwrap();
+                                              child->getMarginForAxis(mainAxis, availableInnerWidth).unwrap() +
+                                              childLayout.computedFlexBasis.unwrap();
           collectedFlexItemsValues.crossDim = availableInnerCrossDim;
-        } else {
+        }
+        else
+        {
           // The main dimension is the sum of all the elements dimension plus
           // the spacing.
           collectedFlexItemsValues.mainDim += betweenMainDim +
-              YGNodeDimWithMargin(child, mainAxis, availableInnerWidth);
+                                              YGNodeDimWithMargin(child, mainAxis, availableInnerWidth);
 
-          if (isNodeBaselineLayout) {
+          if (isNodeBaselineLayout)
+          {
             // If the child is baseline aligned then the cross dimension is
             // calculated by adding maxAscent and maxDescent from the baseline.
             const float ascent = YGBaseline(child, layoutContext) +
-                child
-                    ->getLeadingMargin(
-                        YGFlexDirectionColumn, availableInnerWidth)
-                    .unwrap();
+                                 child
+                                     ->getLeadingMargin(
+                                         YGFlexDirectionColumn, availableInnerWidth)
+                                     .unwrap();
             const float descent =
                 child->getLayout().measuredDimensions[YGDimensionHeight] +
                 child
@@ -2620,7 +2961,9 @@ static void YGJustifyMainAxis(
                 YGFloatMax(maxAscentForCurrentLine, ascent);
             maxDescentForCurrentLine =
                 YGFloatMax(maxDescentForCurrentLine, descent);
-          } else {
+          }
+          else
+          {
             // The cross dimension is the max of the elements dimension since
             // there can only be one element in that cross dimension in the case
             // when the items are not baseline aligned
@@ -2629,7 +2972,9 @@ static void YGJustifyMainAxis(
                 YGNodeDimWithMargin(child, crossAxis, availableInnerWidth));
           }
         }
-      } else if (performLayout) {
+      }
+      else if (performLayout)
+      {
         child->setLayoutPosition(
             childLayout.position[pos[mainAxis]] +
                 node->getLeadingBorder(mainAxis) + leadingMainDim,
@@ -2639,7 +2984,8 @@ static void YGJustifyMainAxis(
   }
   collectedFlexItemsValues.mainDim += trailingPaddingAndBorderMain;
 
-  if (isNodeBaselineLayout) {
+  if (isNodeBaselineLayout)
+  {
     collectedFlexItemsValues.crossDim =
         maxAscentForCurrentLine + maxDescentForCurrentLine;
   }
@@ -2721,11 +3067,12 @@ static void YGNodelayoutImpl(
     const float ownerHeight,
     const bool performLayout,
     const YGConfigRef config,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     const uint32_t depth,
     const uint32_t generationCount,
-    const LayoutPassReason reason) {
+    const LayoutPassReason reason)
+{
   YGAssertWithNode(
       node,
       YGFloatIsUndefined(availableWidth)
@@ -2790,7 +3137,8 @@ static void YGNodelayoutImpl(
       node->getTrailingPadding(flexColumnDirection, ownerWidth).unwrap(),
       YGEdgeBottom);
 
-  if (node->hasMeasureFunc()) {
+  if (node->hasMeasureFunc())
+  {
     YGNodeWithMeasureFuncSetMeasuredDimensions(
         node,
         availableWidth - marginAxisRow,
@@ -2806,7 +3154,8 @@ static void YGNodelayoutImpl(
   }
 
   const uint32_t childCount = YGNodeGetChildCount(node);
-  if (childCount == 0) {
+  if (childCount == 0)
+  {
     YGNodeEmptyContainerSetMeasuredDimensions(
         node,
         availableWidth - marginAxisRow,
@@ -2828,7 +3177,8 @@ static void YGNodelayoutImpl(
           widthMeasureMode,
           heightMeasureMode,
           ownerWidth,
-          ownerHeight)) {
+          ownerHeight))
+  {
     return;
   }
 
@@ -2906,7 +3256,8 @@ static void YGNodelayoutImpl(
       depth,
       generationCount);
 
-  if (childCount > 1) {
+  if (childCount > 1)
+  {
     totalMainDim +=
         node->getGapForAxis(mainAxis, availableInnerCrossDim).unwrap() *
         (childCount - 1);
@@ -2917,7 +3268,8 @@ static void YGNodelayoutImpl(
       totalMainDim > availableInnerMainDim;
 
   if (isNodeFlexWrap && mainAxisOverflows &&
-      measureModeMainDim == YGMeasureModeAtMost) {
+      measureModeMainDim == YGMeasureModeAtMost)
+  {
     measureModeMainDim = YGMeasureModeExactly;
   }
   // STEP 4: COLLECT FLEX ITEMS INTO FLEX LINES
@@ -2939,7 +3291,8 @@ static void YGNodelayoutImpl(
   float maxLineMainDim = 0;
   YGCollectFlexItemsRowValues collectedFlexItemsValues;
   for (; endOfLineIndex < childCount;
-       lineCount++, startOfLineIndex = endOfLineIndex) {
+       lineCount++, startOfLineIndex = endOfLineIndex)
+  {
     collectedFlexItemsValues = YGCalculateCollectFlexItemsRowValues(
         node,
         ownerDirection,
@@ -2963,9 +3316,10 @@ static void YGNodelayoutImpl(
     bool sizeBasedOnContent = false;
     // If we don't measure with exact main dimension we want to ensure we don't
     // violate min and max
-    if (measureModeMainDim != YGMeasureModeExactly) {
-      const auto& minDimensions = node->getStyle().minDimensions();
-      const auto& maxDimensions = node->getStyle().maxDimensions();
+    if (measureModeMainDim != YGMeasureModeExactly)
+    {
+      const auto &minDimensions = node->getStyle().minDimensions();
+      const auto &maxDimensions = node->getStyle().maxDimensions();
       const float minInnerWidth =
           YGResolveValue(minDimensions[YGDimensionWidth], ownerWidth).unwrap() -
           paddingAndBorderAxisRow;
@@ -2988,20 +3342,26 @@ static void YGNodelayoutImpl(
 
       if (!YGFloatIsUndefined(minInnerMainDim) &&
           collectedFlexItemsValues.sizeConsumedOnCurrentLine <
-              minInnerMainDim) {
+              minInnerMainDim)
+      {
         availableInnerMainDim = minInnerMainDim;
-      } else if (
+      }
+      else if (
           !YGFloatIsUndefined(maxInnerMainDim) &&
           collectedFlexItemsValues.sizeConsumedOnCurrentLine >
-              maxInnerMainDim) {
+              maxInnerMainDim)
+      {
         availableInnerMainDim = maxInnerMainDim;
-      } else {
+      }
+      else
+      {
         if (!node->getConfig()->useLegacyStretchBehaviour &&
             ((!YGFloatIsUndefined(
                   collectedFlexItemsValues.totalFlexGrowFactors) &&
               collectedFlexItemsValues.totalFlexGrowFactors == 0) ||
              (!YGFloatIsUndefined(node->resolveFlexGrow()) &&
-              node->resolveFlexGrow() == 0))) {
+              node->resolveFlexGrow() == 0)))
+        {
           // If we don't have any children to flex or we can't flex the node
           // itself, space we've used is all space we need. Root node also
           // should be shrunk to minimum
@@ -3009,17 +3369,21 @@ static void YGNodelayoutImpl(
               collectedFlexItemsValues.sizeConsumedOnCurrentLine;
         }
 
-        if (node->getConfig()->useLegacyStretchBehaviour) {
+        if (node->getConfig()->useLegacyStretchBehaviour)
+        {
           node->setLayoutDidUseLegacyFlag(true);
         }
         sizeBasedOnContent = !node->getConfig()->useLegacyStretchBehaviour;
       }
     }
 
-    if (!sizeBasedOnContent && !YGFloatIsUndefined(availableInnerMainDim)) {
+    if (!sizeBasedOnContent && !YGFloatIsUndefined(availableInnerMainDim))
+    {
       collectedFlexItemsValues.remainingFreeSpace = availableInnerMainDim -
-          collectedFlexItemsValues.sizeConsumedOnCurrentLine;
-    } else if (collectedFlexItemsValues.sizeConsumedOnCurrentLine < 0) {
+                                                    collectedFlexItemsValues.sizeConsumedOnCurrentLine;
+    }
+    else if (collectedFlexItemsValues.sizeConsumedOnCurrentLine < 0)
+    {
       // availableInnerMainDim is indefinite which means the node is being sized
       // based on its content. sizeConsumedOnCurrentLine is negative which means
       // the node will allocate 0 points for its content. Consequently,
@@ -3028,7 +3392,8 @@ static void YGNodelayoutImpl(
           -collectedFlexItemsValues.sizeConsumedOnCurrentLine;
     }
 
-    if (!canSkipFlex) {
+    if (!canSkipFlex)
+    {
       YGResolveFlexibleLength(
           node,
           collectedFlexItemsValues,
@@ -3050,7 +3415,7 @@ static void YGNodelayoutImpl(
     }
 
     node->setLayoutHadOverflow(
-        node->getLayout().hadOverflow() |
+        node->getLayout().hadOverflow() ||
         (collectedFlexItemsValues.remainingFreeSpace < 0));
 
     // STEP 6: MAIN-AXIS JUSTIFICATION & CROSS-AXIS SIZE DETERMINATION
@@ -3078,7 +3443,8 @@ static void YGNodelayoutImpl(
 
     float containerCrossAxis = availableInnerCrossDim;
     if (measureModeCrossDim == YGMeasureModeUndefined ||
-        measureModeCrossDim == YGMeasureModeAtMost) {
+        measureModeCrossDim == YGMeasureModeAtMost)
+    {
       // Compute the cross axis from the max cross dimension of the children.
       containerCrossAxis =
           YGNodeBoundAxis(
@@ -3091,7 +3457,8 @@ static void YGNodelayoutImpl(
     }
 
     // If there's no flex wrap, the cross dimension is defined by the container.
-    if (!isNodeFlexWrap && measureModeCrossDim == YGMeasureModeExactly) {
+    if (!isNodeFlexWrap && measureModeCrossDim == YGMeasureModeExactly)
+    {
       collectedFlexItemsValues.crossDim = availableInnerCrossDim;
     }
 
@@ -3107,19 +3474,24 @@ static void YGNodelayoutImpl(
 
     // STEP 7: CROSS-AXIS ALIGNMENT
     // We can skip child alignment if we're just measuring the container.
-    if (performLayout) {
-      for (uint32_t i = startOfLineIndex; i < endOfLineIndex; i++) {
+    if (performLayout)
+    {
+      for (uint32_t i = startOfLineIndex; i < endOfLineIndex; i++)
+      {
         const YGNodeRef child = node->getChild(i);
-        if (child->getStyle().display() == YGDisplayNone) {
+        if (child->getStyle().display() == YGDisplayNone)
+        {
           continue;
         }
-        if (child->getStyle().positionType() == YGPositionTypeAbsolute) {
+        if (child->getStyle().positionType() == YGPositionTypeAbsolute)
+        {
           // If the child is absolutely positioned and has a
           // top/left/bottom/right set, override all the previously computed
           // positions to set it correctly.
           const bool isChildLeadingPosDefined =
               child->isLeadingPositionDefined(crossAxis);
-          if (isChildLeadingPosDefined) {
+          if (isChildLeadingPosDefined)
+          {
             child->setLayoutPosition(
                 child->getLeadingPosition(crossAxis, availableInnerCrossDim)
                         .unwrap() +
@@ -3131,14 +3503,17 @@ static void YGNodelayoutImpl(
           // If leading position is not defined or calculations result in Nan,
           // default to border + margin
           if (!isChildLeadingPosDefined ||
-              YGFloatIsUndefined(child->getLayout().position[pos[crossAxis]])) {
+              YGFloatIsUndefined(child->getLayout().position[pos[crossAxis]]))
+          {
             child->setLayoutPosition(
                 node->getLeadingBorder(crossAxis) +
                     child->getLeadingMargin(crossAxis, availableInnerWidth)
                         .unwrap(),
                 pos[crossAxis]);
           }
-        } else {
+        }
+        else
+        {
           float leadingCrossDim = leadingPaddingAndBorderCross;
 
           // For a relative children, we're either using alignItems (owner) or
@@ -3151,21 +3526,23 @@ static void YGNodelayoutImpl(
           // cross size for the current line.
           if (alignItem == YGAlignStretch &&
               child->marginLeadingValue(crossAxis).unit != YGUnitAuto &&
-              child->marginTrailingValue(crossAxis).unit != YGUnitAuto) {
+              child->marginTrailingValue(crossAxis).unit != YGUnitAuto)
+          {
             // If the child defines a definite size for its cross axis, there's
             // no need to stretch.
             if (!YGNodeIsStyleDimDefined(
-                    child, crossAxis, availableInnerCrossDim)) {
+                    child, crossAxis, availableInnerCrossDim))
+            {
               float childMainSize =
                   child->getLayout().measuredDimensions[dim[mainAxis]];
-              const auto& childStyle = child->getStyle();
+              const auto &childStyle = child->getStyle();
               float childCrossSize = !childStyle.aspectRatio().isUndefined()
-                  ? child->getMarginForAxis(crossAxis, availableInnerWidth)
-                          .unwrap() +
-                      (isMainAxisRow
-                           ? childMainSize / childStyle.aspectRatio().unwrap()
-                           : childMainSize * childStyle.aspectRatio().unwrap())
-                  : collectedFlexItemsValues.crossDim;
+                                         ? child->getMarginForAxis(crossAxis, availableInnerWidth)
+                                                   .unwrap() +
+                                               (isMainAxisRow
+                                                    ? childMainSize / childStyle.aspectRatio().unwrap()
+                                                    : childMainSize * childStyle.aspectRatio().unwrap())
+                                         : collectedFlexItemsValues.crossDim;
 
               childMainSize +=
                   child->getMarginForAxis(mainAxis, availableInnerWidth)
@@ -3198,14 +3575,14 @@ static void YGNodelayoutImpl(
                   alignContent != YGAlignStretch && isNodeFlexWrap;
               const YGMeasureMode childWidthMeasureMode =
                   YGFloatIsUndefined(childWidth) ||
-                      (!isMainAxisRow && crossAxisDoesNotGrow)
-                  ? YGMeasureModeUndefined
-                  : YGMeasureModeExactly;
+                          (!isMainAxisRow && crossAxisDoesNotGrow)
+                      ? YGMeasureModeUndefined
+                      : YGMeasureModeExactly;
               const YGMeasureMode childHeightMeasureMode =
                   YGFloatIsUndefined(childHeight) ||
-                      (isMainAxisRow && crossAxisDoesNotGrow)
-                  ? YGMeasureModeUndefined
-                  : YGMeasureModeExactly;
+                          (isMainAxisRow && crossAxisDoesNotGrow)
+                      ? YGMeasureModeUndefined
+                      : YGMeasureModeExactly;
 
               YGLayoutNodeInternal(
                   child,
@@ -3224,24 +3601,37 @@ static void YGNodelayoutImpl(
                   depth,
                   generationCount);
             }
-          } else {
+          }
+          else
+          {
             const float remainingCrossDim = containerCrossAxis -
-                YGNodeDimWithMargin(child, crossAxis, availableInnerWidth);
+                                            YGNodeDimWithMargin(child, crossAxis, availableInnerWidth);
 
             if (child->marginLeadingValue(crossAxis).unit == YGUnitAuto &&
-                child->marginTrailingValue(crossAxis).unit == YGUnitAuto) {
+                child->marginTrailingValue(crossAxis).unit == YGUnitAuto)
+            {
               leadingCrossDim += YGFloatMax(0.0f, remainingCrossDim / 2);
-            } else if (
-                child->marginTrailingValue(crossAxis).unit == YGUnitAuto) {
+            }
+            else if (
+                child->marginTrailingValue(crossAxis).unit == YGUnitAuto)
+            {
               // No-Op
-            } else if (
-                child->marginLeadingValue(crossAxis).unit == YGUnitAuto) {
+            }
+            else if (
+                child->marginLeadingValue(crossAxis).unit == YGUnitAuto)
+            {
               leadingCrossDim += YGFloatMax(0.0f, remainingCrossDim);
-            } else if (alignItem == YGAlignFlexStart) {
+            }
+            else if (alignItem == YGAlignFlexStart)
+            {
               // No-Op
-            } else if (alignItem == YGAlignCenter) {
+            }
+            else if (alignItem == YGAlignCenter)
+            {
               leadingCrossDim += remainingCrossDim / 2;
-            } else {
+            }
+            else
+            {
               leadingCrossDim += remainingCrossDim;
             }
           }
@@ -3262,47 +3652,57 @@ static void YGNodelayoutImpl(
 
   // STEP 8: MULTI-LINE CONTENT ALIGNMENT
   // currentLead stores the size of the cross dim
-  if (performLayout && (isNodeFlexWrap || YGIsBaselineLayout(node))) {
+  if (performLayout && (isNodeFlexWrap || YGIsBaselineLayout(node)))
+  {
     float crossDimLead = 0;
     float currentLead = leadingPaddingAndBorderCross;
-    if (!YGFloatIsUndefined(availableInnerCrossDim)) {
+    if (!YGFloatIsUndefined(availableInnerCrossDim))
+    {
       const float remainingAlignContentDim =
           availableInnerCrossDim - totalLineCrossDim;
-      switch (node->getStyle().alignContent()) {
-        case YGAlignFlexEnd:
-          currentLead += remainingAlignContentDim;
-          break;
-        case YGAlignCenter:
-          currentLead += remainingAlignContentDim / 2;
-          break;
-        case YGAlignStretch:
-          if (availableInnerCrossDim > totalLineCrossDim) {
+      switch (node->getStyle().alignContent())
+      {
+      case YGAlignFlexEnd:
+        currentLead += remainingAlignContentDim;
+        break;
+      case YGAlignCenter:
+        currentLead += remainingAlignContentDim / 2;
+        break;
+      case YGAlignStretch:
+        if (availableInnerCrossDim > totalLineCrossDim)
+        {
+          crossDimLead = remainingAlignContentDim / lineCount;
+        }
+        break;
+      case YGAlignSpaceAround:
+        if (availableInnerCrossDim > totalLineCrossDim)
+        {
+          currentLead += remainingAlignContentDim / (2 * lineCount);
+          if (lineCount > 1)
+          {
             crossDimLead = remainingAlignContentDim / lineCount;
           }
-          break;
-        case YGAlignSpaceAround:
-          if (availableInnerCrossDim > totalLineCrossDim) {
-            currentLead += remainingAlignContentDim / (2 * lineCount);
-            if (lineCount > 1) {
-              crossDimLead = remainingAlignContentDim / lineCount;
-            }
-          } else {
-            currentLead += remainingAlignContentDim / 2;
-          }
-          break;
-        case YGAlignSpaceBetween:
-          if (availableInnerCrossDim > totalLineCrossDim && lineCount > 1) {
-            crossDimLead = remainingAlignContentDim / (lineCount - 1);
-          }
-          break;
-        case YGAlignAuto:
-        case YGAlignFlexStart:
-        case YGAlignBaseline:
-          break;
+        }
+        else
+        {
+          currentLead += remainingAlignContentDim / 2;
+        }
+        break;
+      case YGAlignSpaceBetween:
+        if (availableInnerCrossDim > totalLineCrossDim && lineCount > 1)
+        {
+          crossDimLead = remainingAlignContentDim / (lineCount - 1);
+        }
+        break;
+      case YGAlignAuto:
+      case YGAlignFlexStart:
+      case YGAlignBaseline:
+        break;
       }
     }
     uint32_t endIndex = 0;
-    for (uint32_t i = 0; i < lineCount; i++) {
+    for (uint32_t i = 0; i < lineCount; i++)
+    {
       const uint32_t startIndex = endIndex;
       uint32_t ii;
 
@@ -3310,28 +3710,34 @@ static void YGNodelayoutImpl(
       float lineHeight = 0;
       float maxAscentForCurrentLine = 0;
       float maxDescentForCurrentLine = 0;
-      for (ii = startIndex; ii < childCount; ii++) {
+      for (ii = startIndex; ii < childCount; ii++)
+      {
         const YGNodeRef child = node->getChild(ii);
-        if (child->getStyle().display() == YGDisplayNone) {
+        if (child->getStyle().display() == YGDisplayNone)
+        {
           continue;
         }
-        if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
-          if (child->getLineIndex() != i) {
+        if (child->getStyle().positionType() != YGPositionTypeAbsolute)
+        {
+          if (child->getLineIndex() != i)
+          {
             break;
           }
-          if (YGNodeIsLayoutDimDefined(child, crossAxis)) {
+          if (YGNodeIsLayoutDimDefined(child, crossAxis))
+          {
             lineHeight = YGFloatMax(
                 lineHeight,
                 child->getLayout().measuredDimensions[dim[crossAxis]] +
                     child->getMarginForAxis(crossAxis, availableInnerWidth)
                         .unwrap());
           }
-          if (YGNodeAlignItem(node, child) == YGAlignBaseline) {
+          if (YGNodeAlignItem(node, child) == YGAlignBaseline)
+          {
             const float ascent = YGBaseline(child, layoutContext) +
-                child
-                    ->getLeadingMargin(
-                        YGFlexDirectionColumn, availableInnerWidth)
-                    .unwrap();
+                                 child
+                                     ->getLeadingMargin(
+                                         YGFlexDirectionColumn, availableInnerWidth)
+                                     .unwrap();
             const float descent =
                 child->getLayout().measuredDimensions[YGDimensionHeight] +
                 child
@@ -3352,109 +3758,121 @@ static void YGNodelayoutImpl(
       lineHeight += crossDimLead;
       currentLead += i != 0 ? crossAxisGap : 0;
 
-      if (performLayout) {
-        for (ii = startIndex; ii < endIndex; ii++) {
+      if (performLayout)
+      {
+        for (ii = startIndex; ii < endIndex; ii++)
+        {
           const YGNodeRef child = node->getChild(ii);
-          if (child->getStyle().display() == YGDisplayNone) {
+          if (child->getStyle().display() == YGDisplayNone)
+          {
             continue;
           }
-          if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
-            switch (YGNodeAlignItem(node, child)) {
-              case YGAlignFlexStart: {
-                child->setLayoutPosition(
-                    currentLead +
-                        child->getLeadingMargin(crossAxis, availableInnerWidth)
-                            .unwrap(),
-                    pos[crossAxis]);
-                break;
-              }
-              case YGAlignFlexEnd: {
-                child->setLayoutPosition(
-                    currentLead + lineHeight -
-                        child->getTrailingMargin(crossAxis, availableInnerWidth)
-                            .unwrap() -
-                        child->getLayout().measuredDimensions[dim[crossAxis]],
-                    pos[crossAxis]);
-                break;
-              }
-              case YGAlignCenter: {
-                float childHeight =
-                    child->getLayout().measuredDimensions[dim[crossAxis]];
-
-                child->setLayoutPosition(
-                    currentLead + (lineHeight - childHeight) / 2,
-                    pos[crossAxis]);
-                break;
-              }
-              case YGAlignStretch: {
-                child->setLayoutPosition(
-                    currentLead +
-                        child->getLeadingMargin(crossAxis, availableInnerWidth)
-                            .unwrap(),
-                    pos[crossAxis]);
-
-                // Remeasure child with the line height as it as been only
-                // measured with the owners height yet.
-                if (!YGNodeIsStyleDimDefined(
-                        child, crossAxis, availableInnerCrossDim)) {
-                  const float childWidth = isMainAxisRow
-                      ? (child->getLayout()
-                             .measuredDimensions[YGDimensionWidth] +
-                         child->getMarginForAxis(mainAxis, availableInnerWidth)
-                             .unwrap())
-                      : lineHeight;
-
-                  const float childHeight = !isMainAxisRow
-                      ? (child->getLayout()
-                             .measuredDimensions[YGDimensionHeight] +
-                         child->getMarginForAxis(crossAxis, availableInnerWidth)
-                             .unwrap())
-                      : lineHeight;
-
-                  if (!(YGFloatsEqual(
-                            childWidth,
-                            child->getLayout()
-                                .measuredDimensions[YGDimensionWidth]) &&
-                        YGFloatsEqual(
-                            childHeight,
-                            child->getLayout()
-                                .measuredDimensions[YGDimensionHeight]))) {
-                    YGLayoutNodeInternal(
-                        child,
-                        childWidth,
-                        childHeight,
-                        direction,
-                        YGMeasureModeExactly,
-                        YGMeasureModeExactly,
-                        availableInnerWidth,
-                        availableInnerHeight,
-                        true,
-                        LayoutPassReason::kMultilineStretch,
-                        config,
-                        layoutMarkerData,
-                        layoutContext,
-                        depth,
-                        generationCount);
-                  }
+          if (child->getStyle().positionType() != YGPositionTypeAbsolute)
+          {
+            switch (YGNodeAlignItem(node, child))
+            {
+            case YGAlignFlexStart:
+            {
+              child->setLayoutPosition(
+                  currentLead +
+                      child->getLeadingMargin(crossAxis, availableInnerWidth)
+                          .unwrap(),
+                  pos[crossAxis]);
+              break;
+            }
+            case YGAlignFlexEnd:
+            {
+              child->setLayoutPosition(
+                  currentLead + lineHeight -
+                      child->getTrailingMargin(crossAxis, availableInnerWidth)
+                          .unwrap() -
+                      child->getLayout().measuredDimensions[dim[crossAxis]],
+                  pos[crossAxis]);
+              break;
+            }
+            case YGAlignCenter:
+            {
+              float childHeight =
+                  child->getLayout().measuredDimensions[dim[crossAxis]];
+
+              child->setLayoutPosition(
+                  currentLead + (lineHeight - childHeight) / 2,
+                  pos[crossAxis]);
+              break;
+            }
+            case YGAlignStretch:
+            {
+              child->setLayoutPosition(
+                  currentLead +
+                      child->getLeadingMargin(crossAxis, availableInnerWidth)
+                          .unwrap(),
+                  pos[crossAxis]);
+
+              // Remeasure child with the line height as it as been only
+              // measured with the owners height yet.
+              if (!YGNodeIsStyleDimDefined(
+                      child, crossAxis, availableInnerCrossDim))
+              {
+                const float childWidth = isMainAxisRow
+                                             ? (child->getLayout()
+                                                    .measuredDimensions[YGDimensionWidth] +
+                                                child->getMarginForAxis(mainAxis, availableInnerWidth)
+                                                    .unwrap())
+                                             : lineHeight;
+
+                const float childHeight = !isMainAxisRow
+                                              ? (child->getLayout()
+                                                     .measuredDimensions[YGDimensionHeight] +
+                                                 child->getMarginForAxis(crossAxis, availableInnerWidth)
+                                                     .unwrap())
+                                              : lineHeight;
+
+                if (!(YGFloatsEqual(
+                          childWidth,
+                          child->getLayout()
+                              .measuredDimensions[YGDimensionWidth]) &&
+                      YGFloatsEqual(
+                          childHeight,
+                          child->getLayout()
+                              .measuredDimensions[YGDimensionHeight])))
+                {
+                  YGLayoutNodeInternal(
+                      child,
+                      childWidth,
+                      childHeight,
+                      direction,
+                      YGMeasureModeExactly,
+                      YGMeasureModeExactly,
+                      availableInnerWidth,
+                      availableInnerHeight,
+                      true,
+                      LayoutPassReason::kMultilineStretch,
+                      config,
+                      layoutMarkerData,
+                      layoutContext,
+                      depth,
+                      generationCount);
                 }
-                break;
-              }
-              case YGAlignBaseline: {
-                child->setLayoutPosition(
-                    currentLead + maxAscentForCurrentLine -
-                        YGBaseline(child, layoutContext) +
-                        child
-                            ->getLeadingPosition(
-                                YGFlexDirectionColumn, availableInnerCrossDim)
-                            .unwrap(),
-                    YGEdgeTop);
-
-                break;
               }
-              case YGAlignAuto:
-              case YGAlignSpaceBetween:
-              case YGAlignSpaceAround:
-                break;
+              break;
+            }
+            case YGAlignBaseline:
+            {
+              child->setLayoutPosition(
+                  currentLead + maxAscentForCurrentLine -
+                      YGBaseline(child, layoutContext) +
+                      child
+                          ->getLeadingPosition(
+                              YGFlexDirectionColumn, availableInnerCrossDim)
+                          .unwrap(),
+                  YGEdgeTop);
+
+              break;
+            }
+            case YGAlignAuto:
+            case YGAlignSpaceBetween:
+            case YGAlignSpaceAround:
+              break;
             }
           }
         }
@@ -3487,17 +3905,19 @@ static void YGNodelayoutImpl(
   // dimensions based on the children.
   if (measureModeMainDim == YGMeasureModeUndefined ||
       (node->getStyle().overflow() != YGOverflowScroll &&
-       measureModeMainDim == YGMeasureModeAtMost)) {
+       measureModeMainDim == YGMeasureModeAtMost))
+  {
     // Clamp the size to the min/max size, if specified, and make sure it
     // doesn't go below the padding and border amount.
     node->setLayoutMeasuredDimension(
         YGNodeBoundAxis(
             node, mainAxis, maxLineMainDim, mainAxisownerSize, ownerWidth),
         dim[mainAxis]);
-
-  } else if (
+  }
+  else if (
       measureModeMainDim == YGMeasureModeAtMost &&
-      node->getStyle().overflow() == YGOverflowScroll) {
+      node->getStyle().overflow() == YGOverflowScroll)
+  {
     node->setLayoutMeasuredDimension(
         YGFloatMax(
             YGFloatMin(
@@ -3514,7 +3934,8 @@ static void YGNodelayoutImpl(
 
   if (measureModeCrossDim == YGMeasureModeUndefined ||
       (node->getStyle().overflow() != YGOverflowScroll &&
-       measureModeCrossDim == YGMeasureModeAtMost)) {
+       measureModeCrossDim == YGMeasureModeAtMost))
+  {
     // Clamp the size to the min/max size, if specified, and make sure it
     // doesn't go below the padding and border amount.
     node->setLayoutMeasuredDimension(
@@ -3525,10 +3946,11 @@ static void YGNodelayoutImpl(
             crossAxisownerSize,
             ownerWidth),
         dim[crossAxis]);
-
-  } else if (
+  }
+  else if (
       measureModeCrossDim == YGMeasureModeAtMost &&
-      node->getStyle().overflow() == YGOverflowScroll) {
+      node->getStyle().overflow() == YGOverflowScroll)
+  {
     node->setLayoutMeasuredDimension(
         YGFloatMax(
             YGFloatMin(
@@ -3546,10 +3968,13 @@ static void YGNodelayoutImpl(
 
   // As we only wrapped in normal direction yet, we need to reverse the
   // positions on wrap-reverse.
-  if (performLayout && node->getStyle().flexWrap() == YGWrapWrapReverse) {
-    for (uint32_t i = 0; i < childCount; i++) {
+  if (performLayout && node->getStyle().flexWrap() == YGWrapWrapReverse)
+  {
+    for (uint32_t i = 0; i < childCount; i++)
+    {
       const YGNodeRef child = YGNodeGetChild(node, i);
-      if (child->getStyle().positionType() != YGPositionTypeAbsolute) {
+      if (child->getStyle().positionType() != YGPositionTypeAbsolute)
+      {
         child->setLayoutPosition(
             node->getLayout().measuredDimensions[dim[crossAxis]] -
                 child->getLayout().position[pos[crossAxis]] -
@@ -3559,11 +3984,14 @@ static void YGNodelayoutImpl(
     }
   }
 
-  if (performLayout) {
+  if (performLayout)
+  {
     // STEP 10: SIZING AND POSITIONING ABSOLUTE CHILDREN
-    for (auto child : node->getChildren()) {
+    for (auto child : node->getChildren())
+    {
       if (child->getStyle().display() == YGDisplayNone ||
-          child->getStyle().positionType() != YGPositionTypeAbsolute) {
+          child->getStyle().positionType() != YGPositionTypeAbsolute)
+      {
         continue;
       }
       YGNodeAbsoluteLayoutChild(
@@ -3582,22 +4010,27 @@ static void YGNodelayoutImpl(
 
     // STEP 11: SETTING TRAILING POSITIONS FOR CHILDREN
     const bool needsMainTrailingPos = mainAxis == YGFlexDirectionRowReverse ||
-        mainAxis == YGFlexDirectionColumnReverse;
+                                      mainAxis == YGFlexDirectionColumnReverse;
     const bool needsCrossTrailingPos = crossAxis == YGFlexDirectionRowReverse ||
-        crossAxis == YGFlexDirectionColumnReverse;
+                                       crossAxis == YGFlexDirectionColumnReverse;
 
     // Set trailing position if necessary.
-    if (needsMainTrailingPos || needsCrossTrailingPos) {
-      for (uint32_t i = 0; i < childCount; i++) {
+    if (needsMainTrailingPos || needsCrossTrailingPos)
+    {
+      for (uint32_t i = 0; i < childCount; i++)
+      {
         const YGNodeRef child = node->getChild(i);
-        if (child->getStyle().display() == YGDisplayNone) {
+        if (child->getStyle().display() == YGDisplayNone)
+        {
           continue;
         }
-        if (needsMainTrailingPos) {
+        if (needsMainTrailingPos)
+        {
           YGNodeSetChildTrailingPosition(node, child, mainAxis);
         }
 
-        if (needsCrossTrailingPos) {
+        if (needsCrossTrailingPos)
+        {
           YGNodeSetChildTrailingPosition(node, child, crossAxis);
         }
       }
@@ -3608,27 +4041,33 @@ static void YGNodelayoutImpl(
 bool gPrintChanges = false;
 bool gPrintSkips = false;
 
-static const char* spacer =
+static const char *spacer =
     "                                                            ";
 
-static const char* YGSpacer(const unsigned long level) {
+static const char *YGSpacer(const unsigned long level)
+{
   const size_t spacerLen = strlen(spacer);
-  if (level > spacerLen) {
+  if (level > spacerLen)
+  {
     return &spacer[0];
-  } else {
+  }
+  else
+  {
     return &spacer[spacerLen - level];
   }
 }
 
-static const char* YGMeasureModeName(
+static const char *YGMeasureModeName(
     const YGMeasureMode mode,
-    const bool performLayout) {
+    const bool performLayout)
+{
   constexpr auto N = enums::count<YGMeasureMode>();
-  const char* kMeasureModeNames[N] = {"UNDEFINED", "EXACTLY", "AT_MOST"};
-  const char* kLayoutModeNames[N] = {
+  const char *kMeasureModeNames[N] = {"UNDEFINED", "EXACTLY", "AT_MOST"};
+  const char *kLayoutModeNames[N] = {
       "LAY_UNDEFINED", "LAY_EXACTLY", "LAY_AT_MOST"};
 
-  if (mode >= N) {
+  if (mode >= N)
+  {
     return "";
   }
 
@@ -3638,19 +4077,21 @@ static const char* YGMeasureModeName(
 static inline bool YGMeasureModeSizeIsExactAndMatchesOldMeasuredSize(
     YGMeasureMode sizeMode,
     float size,
-    float lastComputedSize) {
+    float lastComputedSize)
+{
   return sizeMode == YGMeasureModeExactly &&
-      YGFloatsEqual(size, lastComputedSize);
+         YGFloatsEqual(size, lastComputedSize);
 }
 
 static inline bool YGMeasureModeOldSizeIsUnspecifiedAndStillFits(
     YGMeasureMode sizeMode,
     float size,
     YGMeasureMode lastSizeMode,
-    float lastComputedSize) {
+    float lastComputedSize)
+{
   return sizeMode == YGMeasureModeAtMost &&
-      lastSizeMode == YGMeasureModeUndefined &&
-      (size >= lastComputedSize || YGFloatsEqual(size, lastComputedSize));
+         lastSizeMode == YGMeasureModeUndefined &&
+         (size >= lastComputedSize || YGFloatsEqual(size, lastComputedSize));
 }
 
 static inline bool YGMeasureModeNewMeasureSizeIsStricterAndStillValid(
@@ -3658,24 +4099,27 @@ static inline bool YGMeasureModeNewMeasureSizeIsStricterAndStillValid(
     float size,
     YGMeasureMode lastSizeMode,
     float lastSize,
-    float lastComputedSize) {
+    float lastComputedSize)
+{
   return lastSizeMode == YGMeasureModeAtMost &&
-      sizeMode == YGMeasureModeAtMost && !YGFloatIsUndefined(lastSize) &&
-      !YGFloatIsUndefined(size) && !YGFloatIsUndefined(lastComputedSize) &&
-      lastSize > size &&
-      (lastComputedSize <= size || YGFloatsEqual(size, lastComputedSize));
+         sizeMode == YGMeasureModeAtMost && !YGFloatIsUndefined(lastSize) &&
+         !YGFloatIsUndefined(size) && !YGFloatIsUndefined(lastComputedSize) &&
+         lastSize > size &&
+         (lastComputedSize <= size || YGFloatsEqual(size, lastComputedSize));
 }
 
 YOGA_EXPORT float YGRoundValueToPixelGrid(
     const double value,
     const double pointScaleFactor,
     const bool forceCeil,
-    const bool forceFloor) {
+    const bool forceFloor)
+{
   double scaledValue = value * pointScaleFactor;
   // We want to calculate `fractial` such that `floor(scaledValue) = scaledValue
   // - fractial`.
   double fractial = fmod(scaledValue, 1.0);
-  if (fractial < 0) {
+  if (fractial < 0)
+  {
     // This branch is for handling negative numbers for `value`.
     //
     // Regarding `floor` and `ceil`. Note that for a number x, `floor(x) <= x <=
@@ -3693,28 +4137,37 @@ YOGA_EXPORT float YGRoundValueToPixelGrid(
     //   - Finding the `floor`: -2.2 - fractial2 = -2.2 - 0.8 = -3
     ++fractial;
   }
-  if (YGDoubleEqual(fractial, 0)) {
+  if (YGDoubleEqual(fractial, 0))
+  {
     // First we check if the value is already rounded
     scaledValue = scaledValue - fractial;
-  } else if (YGDoubleEqual(fractial, 1.0)) {
+  }
+  else if (YGDoubleEqual(fractial, 1.0))
+  {
     scaledValue = scaledValue - fractial + 1.0;
-  } else if (forceCeil) {
+  }
+  else if (forceCeil)
+  {
     // Next we check if we need to use forced rounding
     scaledValue = scaledValue - fractial + 1.0;
-  } else if (forceFloor) {
+  }
+  else if (forceFloor)
+  {
     scaledValue = scaledValue - fractial;
-  } else {
+  }
+  else
+  {
     // Finally we just round the value
     scaledValue = scaledValue - fractial +
-        (!YGDoubleIsUndefined(fractial) &&
-                 (fractial > 0.5 || YGDoubleEqual(fractial, 0.5))
-             ? 1.0
-             : 0.0);
+                  (!YGDoubleIsUndefined(fractial) &&
+                           (fractial > 0.5 || YGDoubleEqual(fractial, 0.5))
+                       ? 1.0
+                       : 0.0);
   }
   return (YGDoubleIsUndefined(scaledValue) ||
           YGDoubleIsUndefined(pointScaleFactor))
-      ? YGUndefined
-      : (float) (scaledValue / pointScaleFactor);
+             ? YGUndefined
+             : (float)(scaledValue / pointScaleFactor);
 }
 
 YOGA_EXPORT bool YGNodeCanUseCachedMeasurement(
@@ -3730,32 +4183,34 @@ YOGA_EXPORT bool YGNodeCanUseCachedMeasurement(
     const float lastComputedHeight,
     const float marginRow,
     const float marginColumn,
-    const YGConfigRef config) {
+    const YGConfigRef config)
+{
   if ((!YGFloatIsUndefined(lastComputedHeight) && lastComputedHeight < 0) ||
-      (!YGFloatIsUndefined(lastComputedWidth) && lastComputedWidth < 0)) {
+      (!YGFloatIsUndefined(lastComputedWidth) && lastComputedWidth < 0))
+  {
     return false;
   }
   bool useRoundedComparison =
       config != nullptr && config->pointScaleFactor != 0;
   const float effectiveWidth = useRoundedComparison
-      ? YGRoundValueToPixelGrid(width, config->pointScaleFactor, false, false)
-      : width;
+                                   ? YGRoundValueToPixelGrid(width, config->pointScaleFactor, false, false)
+                                   : width;
   const float effectiveHeight = useRoundedComparison
-      ? YGRoundValueToPixelGrid(height, config->pointScaleFactor, false, false)
-      : height;
+                                    ? YGRoundValueToPixelGrid(height, config->pointScaleFactor, false, false)
+                                    : height;
   const float effectiveLastWidth = useRoundedComparison
-      ? YGRoundValueToPixelGrid(
-            lastWidth, config->pointScaleFactor, false, false)
-      : lastWidth;
+                                       ? YGRoundValueToPixelGrid(
+                                             lastWidth, config->pointScaleFactor, false, false)
+                                       : lastWidth;
   const float effectiveLastHeight = useRoundedComparison
-      ? YGRoundValueToPixelGrid(
-            lastHeight, config->pointScaleFactor, false, false)
-      : lastHeight;
+                                        ? YGRoundValueToPixelGrid(
+                                              lastHeight, config->pointScaleFactor, false, false)
+                                        : lastHeight;
 
   const bool hasSameWidthSpec = lastWidthMode == widthMode &&
-      YGFloatsEqual(effectiveLastWidth, effectiveWidth);
+                                YGFloatsEqual(effectiveLastWidth, effectiveWidth);
   const bool hasSameHeightSpec = lastHeightMode == heightMode &&
-      YGFloatsEqual(effectiveLastHeight, effectiveHeight);
+                                 YGFloatsEqual(effectiveLastHeight, effectiveHeight);
 
   const bool widthIsCompatible =
       hasSameWidthSpec ||
@@ -3809,11 +4264,12 @@ bool YGLayoutNodeInternal(
     const bool performLayout,
     const LayoutPassReason reason,
     const YGConfigRef config,
-    LayoutData& layoutMarkerData,
-    void* const layoutContext,
+    LayoutData &layoutMarkerData,
+    void *const layoutContext,
     uint32_t depth,
-    const uint32_t generationCount) {
-  YGLayout* layout = &node->getLayout();
+    const uint32_t generationCount)
+{
+  YGLayout *layout = &node->getLayout();
 
   depth++;
 
@@ -3821,7 +4277,8 @@ bool YGLayoutNodeInternal(
       (node->isDirty() && layout->generationCount != generationCount) ||
       layout->lastOwnerDirection != ownerDirection;
 
-  if (needToVisitNode) {
+  if (needToVisitNode)
+  {
     // Invalidate the cached results.
     layout->nextCachedMeasurementsIndex = 0;
     layout->cachedLayout.availableWidth = -1;
@@ -3832,7 +4289,7 @@ bool YGLayoutNodeInternal(
     layout->cachedLayout.computedHeight = -1;
   }
 
-  YGCachedMeasurement* cachedResults = nullptr;
+  YGCachedMeasurement *cachedResults = nullptr;
 
   // Determine whether the results are already cached. We maintain a separate
   // cache for layouts and measurements. A layout operation modifies the
@@ -3842,7 +4299,8 @@ bool YGLayoutNodeInternal(
   // dimensions. We handle nodes with measure functions specially here because
   // they are the most expensive to measure, so it's worth avoiding redundant
   // measurements if at all possible.
-  if (node->hasMeasureFunc()) {
+  if (node->hasMeasureFunc())
+  {
     const float marginAxisRow =
         node->getMarginForAxis(YGFlexDirectionRow, ownerWidth).unwrap();
     const float marginAxisColumn =
@@ -3862,11 +4320,15 @@ bool YGLayoutNodeInternal(
             layout->cachedLayout.computedHeight,
             marginAxisRow,
             marginAxisColumn,
-            config)) {
+            config))
+    {
       cachedResults = &layout->cachedLayout;
-    } else {
+    }
+    else
+    {
       // Try to use the measurement cache.
-      for (uint32_t i = 0; i < layout->nextCachedMeasurementsIndex; i++) {
+      for (uint32_t i = 0; i < layout->nextCachedMeasurementsIndex; i++)
+      {
         if (YGNodeCanUseCachedMeasurement(
                 widthMeasureMode,
                 availableWidth,
@@ -3880,35 +4342,44 @@ bool YGLayoutNodeInternal(
                 layout->cachedMeasurements[i].computedHeight,
                 marginAxisRow,
                 marginAxisColumn,
-                config)) {
+                config))
+        {
           cachedResults = &layout->cachedMeasurements[i];
           break;
         }
       }
     }
-  } else if (performLayout) {
+  }
+  else if (performLayout)
+  {
     if (YGFloatsEqual(layout->cachedLayout.availableWidth, availableWidth) &&
         YGFloatsEqual(layout->cachedLayout.availableHeight, availableHeight) &&
         layout->cachedLayout.widthMeasureMode == widthMeasureMode &&
-        layout->cachedLayout.heightMeasureMode == heightMeasureMode) {
+        layout->cachedLayout.heightMeasureMode == heightMeasureMode)
+    {
       cachedResults = &layout->cachedLayout;
     }
-  } else {
-    for (uint32_t i = 0; i < layout->nextCachedMeasurementsIndex; i++) {
+  }
+  else
+  {
+    for (uint32_t i = 0; i < layout->nextCachedMeasurementsIndex; i++)
+    {
       if (YGFloatsEqual(
               layout->cachedMeasurements[i].availableWidth, availableWidth) &&
           YGFloatsEqual(
               layout->cachedMeasurements[i].availableHeight, availableHeight) &&
           layout->cachedMeasurements[i].widthMeasureMode == widthMeasureMode &&
           layout->cachedMeasurements[i].heightMeasureMode ==
-              heightMeasureMode) {
+              heightMeasureMode)
+      {
         cachedResults = &layout->cachedMeasurements[i];
         break;
       }
     }
   }
 
-  if (!needToVisitNode && cachedResults != nullptr) {
+  if (!needToVisitNode && cachedResults != nullptr)
+  {
     layout->measuredDimensions[YGDimensionWidth] = cachedResults->computedWidth;
     layout->measuredDimensions[YGDimensionHeight] =
         cachedResults->computedHeight;
@@ -3916,7 +4387,8 @@ bool YGLayoutNodeInternal(
     (performLayout ? layoutMarkerData.cachedLayouts
                    : layoutMarkerData.cachedMeasures) += 1;
 
-    if (gPrintChanges && gPrintSkips) {
+    if (gPrintChanges && gPrintSkips)
+    {
       Log::log(
           node,
           YGLogLevelVerbose,
@@ -3938,8 +4410,11 @@ bool YGLayoutNodeInternal(
           cachedResults->computedHeight,
           LayoutPassReasonToString(reason));
     }
-  } else {
-    if (gPrintChanges) {
+  }
+  else
+  {
+    if (gPrintChanges)
+    {
       Log::log(
           node,
           YGLogLevelVerbose,
@@ -3978,7 +4453,8 @@ bool YGLayoutNodeInternal(
         generationCount,
         reason);
 
-    if (gPrintChanges) {
+    if (gPrintChanges)
+    {
       Log::log(
           node,
           YGLogLevelVerbose,
@@ -4002,24 +4478,31 @@ bool YGLayoutNodeInternal(
 
     layout->lastOwnerDirection = ownerDirection;
 
-    if (cachedResults == nullptr) {
+    if (cachedResults == nullptr)
+    {
       if (layout->nextCachedMeasurementsIndex + 1 >
-          (uint32_t) layoutMarkerData.maxMeasureCache) {
+          (uint32_t)layoutMarkerData.maxMeasureCache)
+      {
         layoutMarkerData.maxMeasureCache =
             layout->nextCachedMeasurementsIndex + 1;
       }
-      if (layout->nextCachedMeasurementsIndex == YG_MAX_CACHED_RESULT_COUNT) {
-        if (gPrintChanges) {
+      if (layout->nextCachedMeasurementsIndex == YG_MAX_CACHED_RESULT_COUNT)
+      {
+        if (gPrintChanges)
+        {
           Log::log(node, YGLogLevelVerbose, nullptr, "Out of cache entries!\n");
         }
         layout->nextCachedMeasurementsIndex = 0;
       }
 
-      YGCachedMeasurement* newCacheEntry;
-      if (performLayout) {
+      YGCachedMeasurement *newCacheEntry;
+      if (performLayout)
+      {
         // Use the single layout cache entry.
         newCacheEntry = &layout->cachedLayout;
-      } else {
+      }
+      else
+      {
         // Allocate a new measurement cache entry.
         newCacheEntry =
             &layout->cachedMeasurements[layout->nextCachedMeasurementsIndex];
@@ -4037,7 +4520,8 @@ bool YGLayoutNodeInternal(
     }
   }
 
-  if (performLayout) {
+  if (performLayout)
+  {
     node->setLayoutDimension(
         node->getLayout().measuredDimensions[YGDimensionWidth],
         YGDimensionWidth);
@@ -4052,11 +4536,14 @@ bool YGLayoutNodeInternal(
   layout->generationCount = generationCount;
 
   LayoutType layoutType;
-  if (performLayout) {
+  if (performLayout)
+  {
     layoutType = !needToVisitNode && cachedResults == &layout->cachedLayout
-        ? LayoutType::kCachedLayout
-        : LayoutType::kLayout;
-  } else {
+                     ? LayoutType::kCachedLayout
+                     : LayoutType::kLayout;
+  }
+  else
+  {
     layoutType = cachedResults != nullptr ? LayoutType::kCachedMeasure
                                           : LayoutType::kMeasure;
   }
@@ -4067,17 +4554,21 @@ bool YGLayoutNodeInternal(
 
 YOGA_EXPORT void YGConfigSetPointScaleFactor(
     const YGConfigRef config,
-    const float pixelsInPoint) {
+    const float pixelsInPoint)
+{
   YGAssertWithConfig(
       config,
       pixelsInPoint >= 0.0f,
       "Scale factor should not be less than zero");
 
   // We store points for Pixel as we will use it for rounding
-  if (pixelsInPoint == 0.0f) {
+  if (pixelsInPoint == 0.0f)
+  {
     // Zero is used to skip rounding
     config->pointScaleFactor = 0.0f;
-  } else {
+  }
+  else
+  {
     config->pointScaleFactor = pixelsInPoint;
   }
 }
@@ -4086,8 +4577,10 @@ static void YGRoundToPixelGrid(
     const YGNodeRef node,
     const double pointScaleFactor,
     const double absoluteLeft,
-    const double absoluteTop) {
-  if (pointScaleFactor == 0.0f) {
+    const double absoluteTop)
+{
+  if (pointScaleFactor == 0.0f)
+  {
     return;
   }
 
@@ -4146,7 +4639,8 @@ static void YGRoundToPixelGrid(
       YGDimensionHeight);
 
   const uint32_t childCount = YGNodeGetChildCount(node);
-  for (uint32_t i = 0; i < childCount; i++) {
+  for (uint32_t i = 0; i < childCount; i++)
+  {
     YGRoundToPixelGrid(
         YGNodeGetChild(node, i),
         pointScaleFactor,
@@ -4155,9 +4649,11 @@ static void YGRoundToPixelGrid(
   }
 }
 
-static void unsetUseLegacyFlagRecursively(YGNodeRef node) {
+static void unsetUseLegacyFlagRecursively(YGNodeRef node)
+{
   node->getConfig()->useLegacyStretchBehaviour = false;
-  for (auto child : node->getChildren()) {
+  for (auto child : node->getChildren())
+  {
     unsetUseLegacyFlagRecursively(child);
   }
 }
@@ -4167,7 +4663,8 @@ YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
     const float ownerWidth,
     const float ownerHeight,
     const YGDirection ownerDirection,
-    void* layoutContext) {
+    void *layoutContext)
+{
 
   Event::publish<Event::LayoutPassStart>(node, {layoutContext});
   LayoutData markerData = {};
@@ -4179,20 +4676,25 @@ YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
   node->resolveDimension();
   float width = YGUndefined;
   YGMeasureMode widthMeasureMode = YGMeasureModeUndefined;
-  const auto& maxDimensions = node->getStyle().maxDimensions();
-  if (YGNodeIsStyleDimDefined(node, YGFlexDirectionRow, ownerWidth)) {
+  const auto &maxDimensions = node->getStyle().maxDimensions();
+  if (YGNodeIsStyleDimDefined(node, YGFlexDirectionRow, ownerWidth))
+  {
     width =
         (YGResolveValue(
              node->getResolvedDimension(dim[YGFlexDirectionRow]), ownerWidth) +
          node->getMarginForAxis(YGFlexDirectionRow, ownerWidth))
             .unwrap();
     widthMeasureMode = YGMeasureModeExactly;
-  } else if (!YGResolveValue(maxDimensions[YGDimensionWidth], ownerWidth)
-                  .isUndefined()) {
+  }
+  else if (!YGResolveValue(maxDimensions[YGDimensionWidth], ownerWidth)
+                .isUndefined())
+  {
     width =
         YGResolveValue(maxDimensions[YGDimensionWidth], ownerWidth).unwrap();
     widthMeasureMode = YGMeasureModeAtMost;
-  } else {
+  }
+  else
+  {
     width = ownerWidth;
     widthMeasureMode = YGFloatIsUndefined(width) ? YGMeasureModeUndefined
                                                  : YGMeasureModeExactly;
@@ -4200,19 +4702,24 @@ YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
 
   float height = YGUndefined;
   YGMeasureMode heightMeasureMode = YGMeasureModeUndefined;
-  if (YGNodeIsStyleDimDefined(node, YGFlexDirectionColumn, ownerHeight)) {
+  if (YGNodeIsStyleDimDefined(node, YGFlexDirectionColumn, ownerHeight))
+  {
     height = (YGResolveValue(
                   node->getResolvedDimension(dim[YGFlexDirectionColumn]),
                   ownerHeight) +
               node->getMarginForAxis(YGFlexDirectionColumn, ownerWidth))
                  .unwrap();
     heightMeasureMode = YGMeasureModeExactly;
-  } else if (!YGResolveValue(maxDimensions[YGDimensionHeight], ownerHeight)
-                  .isUndefined()) {
+  }
+  else if (!YGResolveValue(maxDimensions[YGDimensionHeight], ownerHeight)
+                .isUndefined())
+  {
     height =
         YGResolveValue(maxDimensions[YGDimensionHeight], ownerHeight).unwrap();
     heightMeasureMode = YGMeasureModeAtMost;
-  } else {
+  }
+  else
+  {
     height = ownerHeight;
     heightMeasureMode = YGFloatIsUndefined(height) ? YGMeasureModeUndefined
                                                    : YGMeasureModeExactly;
@@ -4232,16 +4739,18 @@ YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
           markerData,
           layoutContext,
           0, // tree root
-          gCurrentGenerationCount.load(std::memory_order_relaxed))) {
+          gCurrentGenerationCount.load(std::memory_order_relaxed)))
+  {
     node->setPosition(
         node->getLayout().direction(), ownerWidth, ownerHeight, ownerWidth);
     YGRoundToPixelGrid(node, node->getConfig()->pointScaleFactor, 0.0f, 0.0f);
 
 #ifdef DEBUG
-    if (node->getConfig()->printTree) {
+    if (node->getConfig()->printTree)
+    {
       YGNodePrint(
           node,
-          (YGPrintOptions) (YGPrintOptionsLayout | YGPrintOptionsChildren | YGPrintOptionsStyle));
+          (YGPrintOptions)(YGPrintOptionsLayout | YGPrintOptionsChildren | YGPrintOptionsStyle));
     }
 #endif
   }
@@ -4256,7 +4765,8 @@ YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
   // `shouldDiffLayoutWithoutLegacyStretchBehaviour` in YGConfig will help to
   // run experiments.
   if (node->getConfig()->shouldDiffLayoutWithoutLegacyStretchBehaviour &&
-      node->didUseLegacyFlag()) {
+      node->didUseLegacyFlag())
+  {
     const YGNodeRef nodeWithoutLegacyFlag = YGNodeDeepClone(node);
     nodeWithoutLegacyFlag->resolveDimension();
     // Recursively mark nodes as dirty
@@ -4280,7 +4790,8 @@ YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
             layoutMarkerData,
             layoutContext,
             0, // tree root
-            gCurrentGenerationCount.load(std::memory_order_relaxed))) {
+            gCurrentGenerationCount.load(std::memory_order_relaxed)))
+    {
       nodeWithoutLegacyFlag->setPosition(
           nodeWithoutLegacyFlag->getLayout().direction(),
           ownerWidth,
@@ -4298,10 +4809,11 @@ YOGA_EXPORT void YGNodeCalculateLayoutWithContext(
       node->setLayoutDoesLegacyFlagAffectsLayout(neededLegacyStretchBehaviour);
 
 #ifdef DEBUG
-      if (nodeWithoutLegacyFlag->getConfig()->printTree) {
+      if (nodeWithoutLegacyFlag->getConfig()->printTree)
+      {
         YGNodePrint(
             nodeWithoutLegacyFlag,
-            (YGPrintOptions) (YGPrintOptionsLayout | YGPrintOptionsChildren | YGPrintOptionsStyle));
+            (YGPrintOptions)(YGPrintOptionsLayout | YGPrintOptionsChildren | YGPrintOptionsStyle));
       }
 #endif
     }
@@ -4314,15 +4826,20 @@ YOGA_EXPORT void YGNodeCalculateLayout(
     const YGNodeRef node,
     const float ownerWidth,
     const float ownerHeight,
-    const YGDirection ownerDirection) {
+    const YGDirection ownerDirection)
+{
   YGNodeCalculateLayoutWithContext(
       node, ownerWidth, ownerHeight, ownerDirection, nullptr);
 }
 
-YOGA_EXPORT void YGConfigSetLogger(const YGConfigRef config, YGLogger logger) {
-  if (logger != nullptr) {
+YOGA_EXPORT void YGConfigSetLogger(const YGConfigRef config, YGLogger logger)
+{
+  if (logger != nullptr)
+  {
     config->setLogger(logger);
-  } else {
+  }
+  else
+  {
 #ifdef ANDROID
     config->setLogger(&YGAndroidLog);
 #else
@@ -4333,12 +4850,15 @@ YOGA_EXPORT void YGConfigSetLogger(const YGConfigRef config, YGLogger logger) {
 
 YOGA_EXPORT void YGConfigSetShouldDiffLayoutWithoutLegacyStretchBehaviour(
     const YGConfigRef config,
-    const bool shouldDiffLayout) {
+    const bool shouldDiffLayout)
+{
   config->shouldDiffLayoutWithoutLegacyStretchBehaviour = shouldDiffLayout;
 }
 
-void YGAssert(const bool condition, const char* message) {
-  if (!condition) {
+void YGAssert(const bool condition, const char *message)
+{
+  if (!condition)
+  {
     Log::log(YGNodeRef{nullptr}, YGLogLevelFatal, nullptr, "%s\n", message);
     throwLogicalErrorWithMessage(message);
   }
@@ -4347,8 +4867,10 @@ void YGAssert(const bool condition, const char* message) {
 void YGAssertWithNode(
     const YGNodeRef node,
     const bool condition,
-    const char* message) {
-  if (!condition) {
+    const char *message)
+{
+  if (!condition)
+  {
     Log::log(node, YGLogLevelFatal, nullptr, "%s\n", message);
     throwLogicalErrorWithMessage(message);
   }
@@ -4357,8 +4879,10 @@ void YGAssertWithNode(
 void YGAssertWithConfig(
     const YGConfigRef config,
     const bool condition,
-    const char* message) {
-  if (!condition) {
+    const char *message)
+{
+  if (!condition)
+  {
     Log::log(config, YGLogLevelFatal, nullptr, "%s\n", message);
     throwLogicalErrorWithMessage(message);
   }
@@ -4367,55 +4891,66 @@ void YGAssertWithConfig(
 YOGA_EXPORT void YGConfigSetExperimentalFeatureEnabled(
     const YGConfigRef config,
     const YGExperimentalFeature feature,
-    const bool enabled) {
+    const bool enabled)
+{
   config->experimentalFeatures[feature] = enabled;
 }
 
 YOGA_EXPORT bool YGConfigIsExperimentalFeatureEnabled(
     const YGConfigRef config,
-    const YGExperimentalFeature feature) {
+    const YGExperimentalFeature feature)
+{
   return config->experimentalFeatures[feature];
 }
 
 YOGA_EXPORT void YGConfigSetUseWebDefaults(
     const YGConfigRef config,
-    const bool enabled) {
+    const bool enabled)
+{
   config->useWebDefaults = enabled;
 }
 
 YOGA_EXPORT bool YGConfigGetUseLegacyStretchBehaviour(
-    const YGConfigRef config) {
+    const YGConfigRef config)
+{
   return config->useLegacyStretchBehaviour;
 }
 
 YOGA_EXPORT void YGConfigSetUseLegacyStretchBehaviour(
     const YGConfigRef config,
-    const bool useLegacyStretchBehaviour) {
+    const bool useLegacyStretchBehaviour)
+{
   config->useLegacyStretchBehaviour = useLegacyStretchBehaviour;
 }
 
-bool YGConfigGetUseWebDefaults(const YGConfigRef config) {
+bool YGConfigGetUseWebDefaults(const YGConfigRef config)
+{
   return config->useWebDefaults;
 }
 
-YOGA_EXPORT void YGConfigSetContext(const YGConfigRef config, void* context) {
+YOGA_EXPORT void YGConfigSetContext(const YGConfigRef config, void *context)
+{
   config->context = context;
 }
 
-YOGA_EXPORT void* YGConfigGetContext(const YGConfigRef config) {
+YOGA_EXPORT void *YGConfigGetContext(const YGConfigRef config)
+{
   return config->context;
 }
 
 YOGA_EXPORT void YGConfigSetCloneNodeFunc(
     const YGConfigRef config,
-    const YGCloneNodeFunc callback) {
+    const YGCloneNodeFunc callback)
+{
   config->setCloneNodeCallback(callback);
 }
 
 static void YGTraverseChildrenPreOrder(
-    const YGVector& children,
-    const std::function<void(YGNodeRef node)>& f) {
-  for (YGNodeRef node : children) {
+    const YGVector &children,
+    const std::function<void(YGNodeRef node)> &f)
+{
+  for (YGNodeRef node : children)
+  {
     f(node);
     YGTraverseChildrenPreOrder(node->getChildren(), f);
   }
@@ -4423,8 +4958,10 @@ static void YGTraverseChildrenPreOrder(
 
 void YGTraversePreOrder(
     YGNodeRef const node,
-    std::function<void(YGNodeRef node)>&& f) {
-  if (!node) {
+    std::function<void(YGNodeRef node)> &&f)
+{
+  if (!node)
+  {
     return;
   }
   f(node);
